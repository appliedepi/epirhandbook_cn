# 导入与导出 {}


```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Import_Export_1500x500.png"))
```



In this page we describe ways to locate, import, and export files:  

在本页中，我们描述了定位、导入和导出文件的方法:

* Use of the **here** package to locate files relative to an R project root - to prevent complications from file paths that are specific to one computer  
* Specific import scenarios, such as:  
  * Specific Excel sheets  
  * Messy headers and skipping rows  
  * From Google sheets  
  * From data posted to websites  
  * With APIs  
  * Importing the *most recent* file  
* Manual data entry  
* R-specific file types such as RDS and RData  
* Exporting/saving files and plots  


* 使用**rio**包灵活地` import() `和` export() `多种类型的文件
* 使用**here**包来定位相对于R项目根目录的文件-以防止特定于一台计算机的文件路径的复杂性
* 具体导入场景，如:
  * 特定的Excel表
  * 混乱的标题和跳过行
  * 从谷歌表格导入
  * 从发布到网站的数据
  * 与api
  * 正在导入*最近的*文件
* 人工数据输入
* R特定的文件类型，如RDS和RData
* 导出/保存文件和图
  
  


<!-- ======================================================= -->
## Overview

When you import a "dataset" into R, you are generally creating a new *data frame* object in your R environment and defining it as an imported file (e.g. Excel, CSV, TSV, RDS) that is located in your folder directories at a certain file path/address.  

当你导入一个“dataset”到R时，你通常是在你的R环境中创建一个新的*data frame*对象，并将其定义为一个位于文件夹目录中的特定文件路径/地址的导入文件(例如Excel, CSV, TSV, RDS)。

You can import/export many types of files, including those created by other statistical programs (SAS, STATA, SPSS). You can also connect to relational databases.  

您可以导入/导出多种类型的文件，包括由其他统计程序(SAS, STATA, SPSS)创建的文件。您还可以连接到关系数据库

R even has its own data formats:  

R甚至有自己的数据格式:

* An RDS file (.rds) stores a single R object such as a data frame. These are useful to store cleaned data, as they maintain R column classes. Read more in [this section](#import_rds).    
* An RData file (.Rdata) can be used to store multiple objects, or even a complete R workspace. Read more in [this section](#import_rdata).  

* RDS文件(. RDS)存储单个R对象，如数据帧。这对于存储清理后的数据很有用，因为它们维护R列类。更多信息请参阅[本节](#import_rds)。
*RData文件(. RData)可以用来存储多个对象，甚至是一个完整的R工作区。更多信息请参阅[本节](#import_rdata)。

<!-- ======================================================= -->
## The **rio** package {}  

The R package we recommend is: **rio**. The name "rio" is an abbreviation of "R I/O" (input/output).  

我们推荐的R包是:**rio**。“rio”是“R I/O”(输入/输出)的缩写。

Its functions `import()` and `export()` can handle many different file types (e.g. .xlsx, .csv, .rds, .tsv). When you provide a file path to either of these functions (including the file extension like ".csv"), **rio** will read the extension and use the correct tool to import or export the file. 

它的函数`import() `和`export() `可以处理许多不同的文件类型(例如。xlsx， .csv， .rds， .tsv)。当你提供一个文件路径到这些函数(包括文件扩展名“.csv”)，**rio**将读取扩展名并使用正确的工具来导入或导出文件。

The alternative to using **rio** is to use functions from many other packages, each of which is specific to a type of file. For example, `read.csv()` (**base** R), `read.xlsx()` (**openxlsx** package), and `write_csv()` (**readr** pacakge), etc. These alternatives can be difficult to remember, whereas using `import()` and `export()` from **rio** is easy.  

使用**rio**的替代方法是使用来自许多其他包的函数，每个包都特定于一种类型的文件。例如,“read.csv()的(* *base* * R),“read.xlsx()的(* * openxlsx * *包),和“write_csv()的(* * readr * * pacakge),等等。这些替代可能很难记住，而使用' import() '和' export() ' from **rio**很容易。

**rio**'s functions `import()` and `export()` use the appropriate package and function for a given file, based on its file extension. See the end of this page for a complete table of which packages/functions **rio** uses in the background. It can also be used to import STATA, SAS, and SPSS files, among dozens of other file types.  

**rio**' '函数` import()`和` export()` 根据文件的扩展名，对给定的文件使用适当的包和函数。在这个页面的末尾，可以看到一个完整的表格，上面是**rio**在后台使用的包/函数。它还可以用于导入STATA、SAS和SPSS文件，以及其他几十种文件类型。

Import/export of shapefiles requires other packages, as detailed in the page on [GIS basics].    

shapefiles的导入/导出需要其他包，详见[GIS基础知识]一页。




## The **here** package {#here}

The package **here** and its function `here()` make it easy to tell R where to find and to save your files - in essence, it builds file paths.  

包**here**和它的函数' here() '使它很容易告诉R在哪里找到和保存你的文件-本质上，它构建文件路径。

Used in conjunction with an R project, **here** allows you to describe the location of files in your R project in relation to the R project's *root directory* (the top-level folder). This is useful when the R project may be shared or accessed by multiple people/computers. It prevents complications due to the unique file paths on different computers (e.g. `"C:/Users/Laura/Documents..."` by "starting" the file path in a place common to all users (the R project root).  

与R项目一起使用时，这里的**允许你描述R项目中与R项目的*根目录*(顶级文件夹)相关的文件位置。当R项目可能被多人/计算机共享或访问时，这是非常有用的。它防止了由于不同计算机上的独特文件路径(例如:“C: /用户/劳拉/文件…通过在所有用户共同的地方(R项目根目录)“启动”文件路径。

This is how `here()` works within an R project: 

这就是` here()` 在R项目中的工作方式:

* When the **here** package is first loaded within the R project, it places a small file called ".here" in the root folder of your R project as a "benchmark" or "anchor"  
* In your scripts, to reference a file in the R project's sub-folders, you use the function `here()` to build the file path *in relation to that anchor*
* To build the file path, write the names of folders beyond the root, within quotes, separated by commas, finally ending with the file name and file extension as shown below  
* `here()` file paths can be used for both importing and exporting  

* 当**here**包第一次在R项目中加载时，它会放置一个名为“。在R项目的根文件夹中作为“基准”或“锚”
* 在你的脚本中，要在R项目的子文件夹中引用一个文件，你可以使用函数' here() '来构建与锚*相关的文件路径*
* 要构建文件路径，请将根目录之外的文件夹名称用引号括起来，用逗号分隔，最后以文件名和文件扩展名结尾，如下所示
* `here() `文件路径可用于导入和导出

For example, below, the function `import()` is being provided a file path constructed with `here()`.  

例如，下面为函数`import()`提供了一个用' here() '构造的文件路径。
```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```

The command `here("data", "linelists", "ebola_linelist.xlsx")` is actually providing the full file path that is *unique to the user's computer*:  

命令`here("data"， "linelist "， "ebola_linelist.xlsx") `实际上提供了完整的文件路径，该路径是用户计算机*唯一的*:



```
"C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx"
```

The beauty is that the R command using `here()` can be successfully run on any computer accessing the R project.   

美妙之处在于，使用' here() '的R命令可以在任何访问R项目的计算机上成功运行。


<span style="color: darkgreen;">**_TIP:_** If you are unsure where the “.here” root is set to, run the function `here()` with empty parentheses.</span>  

<span style="color: darkgreen;">**_提示:_**如果你不确定“。在这里“root被设置为，运行函数' Here() '带空括号。</span>  

Read more about the **here** package [at this link](https://here.r-lib.org/).  

阅读更多关于**here**包[在这个链接](https://here.r-lib.org/)。

<!-- ======================================================= -->
## File paths  

When importing or exporting data, you must provide a file path. You can do this one of three ways:  

导入或导出数据时，必须提供文件路径。你可以采用以下三种方法:

1) *Recommended:* provide a "relative" file path with the **here** package  
2) Provide the "full" / "absolute" file path  
3) Manual file selection  

1）*推荐:*提供一个“相对”文件路径与**here**包
2）提供"full" / "absolute"文件路径
3）手册文件选择

### "Relative" file paths {.unnumbered}

In R, "relative" file paths consist of the file path *relative to* the root of an R project. They allow for more simple file paths that can work on different computers (e.g. if the R project is on a shared drive or is sent by email). As described [above](#here), relative file paths are facilitated by use of the **here** package.  

在R中，“相对”文件路径包括文件路径相对于R项目的根。它们允许在不同的计算机上工作的更简单的文件路径(例如，如果R项目在共享驱动器上或通过电子邮件发送)。正如[上面](#here)所描述的，使用**here**包可以方便地使用相对文件路径。

An example of a relative file path constructed with `here()` is below. We assume the work is in an R project that contains a sub-folder "data" and within that a subfolder "linelists", in which there is the .xlsx file of interest. 

下面是一个使用' here() '构造的相对文件路径的示例。我们假设工作在一个包含子文件夹“data”和子文件夹“linelists”的R项目中，其中有感兴趣的.xlsx文件。

```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```



### "Absolute" file paths {.unnumbered}  

Absolute or "full" file paths can be provided to functions like `import()` but they are "fragile" as they are unique to the user's specific computer and therefore *not recommended*. 

绝对或“完整”的文件路径可以提供给像' import() '这样的函数，但它们是“脆弱的”，因为它们是用户特定的计算机所独有的，因此*不推荐*。

Below is an example of an absolute file path, where in Laura's computer there is a folder "analysis", a sub-folder "data" and within that a sub-folder "linelists", in which there is the .xlsx file of interest.  

下面是一个绝对文件路径的例子，在Laura的计算机中有一个文件夹“analysis”，一个子文件夹“data”，其中有一个子文件夹“linelists”，其中有一个感兴趣的.xlsx文件。

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/analysis/data/linelists/ebola_linelist.xlsx")
```

A few things to note about absolute file paths:  

关于绝对文件路径，有几点需要注意:

* **Avoid using absolute file paths** as they will break if the script is run on a different computer
* Use *forward* slashes (`/`), as in the example above (note: this is *NOT* the default for Windows file paths)  
* File paths that begin with double slashes (e.g. "//...") will likely **not be recognized by R** and will produce an error. Consider moving your work to a "named" or "lettered" drive that begins with a letter (e.g. "J:" or "C:"). See the page on [Directory interactions] for more details on this issue.  

* **避免使用绝对文件路径**，因为如果脚本在不同的计算机上运行，它们将崩溃
* 使用*前向*斜杠(' / ')，如上例(注意:这不是Windows文件路径的默认值)
* 以双斜杠开头的文件路径(例如:"//…")将可能**不能被R**识别，并将产生一个错误。考虑将你的工作转移到以字母开头的“named”或“letter”驱动器上。“珍:”或“C:”)。有关这个问题的更多细节，请参阅[目录交互]页面。


One scenario where absolute file paths may be appropriate is when you want to import a file from a shared drive that has the same full file path for all users.  

绝对文件路径可能适合的一种情况是，当您希望从共享驱动器导入文件时，该驱动器对所有用户具有相同的完整文件路径。

<span style="color: darkgreen;">**_TIP:_** To quickly convert all `\` to `/`, highlight the code of interest, use Ctrl+f (in Windows), check the option box for "In selection", and then use the replace functionality to convert them.</span>  

<span style="color: darkgreen;">**_TIP:_**为了快速转换所有的‘\’到‘/’，突出显示感兴趣的代码，使用Ctrl+f(在Windows中)，选中“在选择中”的选项框，然后使用替换功能来转换它们。</span> 

<!-- ======================================================= -->
### Select file manually {.unnumbered}

You can import data manually via one of these methods:  

你可以通过以下方法手动导入数据:

1) Environment RStudio Pane, click "Import Dataset", and select the type of data 
2) Click File / Import Dataset / (select the type of data)  
3) To hard-code manual selection, use the *base R* command `file.choose()` (leaving the parentheses empty) to trigger appearance of a **pop-up window** that allows the user to manually select the file from their computer. For example:  

1）环境RStudio窗格，单击“导入数据集”，并选择数据类型
2）点击文件/导入数据集/(选择数据类型)
3）要硬编码手动选择，使用*base R*命令' file.choose() '(括号为空)来触发一个弹出窗口的出现，允许用户从他们的计算机中手动选择文件。例如:

```{r import_choose, eval=F}
# Manual selection of a file. When this command is run, a POP-UP window will appear. 
# The file path selected will be supplied to the import() command.

my_data <- import(file.choose())
```

<span style="color: darkgreen;">**_TIP:_** The **pop-up window** may appear BEHIND your RStudio window.</span>

<span style="color: darkgreen;">** _提示:_**弹出窗口**可能出现在您的RStudio窗口后面。</span>

## Import data  

To use `import()` to import a dataset is quite simple. Simply provide the path to the file (including the file name and file extension) in quotes. If using `here()` to build the file path, follow the instructions above. Below are a few examples: 

使用`import() `导入数据集非常简单。只需在引号中提供文件的路径(包括文件名和文件扩展名)。如果使用`here()` 来构建文件路径，请遵循上面的说明。以下是一些例子:

Importing a csv file that is located in your "working directory" or in the R project root folder:  

导入位于“工作目录”或R项目根文件夹中的csv文件:
```{r, eval=F}
linelist <- import("linelist_cleaned.csv")
```


Importing the first sheet of an Excel workbook that is located in "data" and "linelists" sub-folders of the R project (the file path built using `here()`):  

导入位于R项目的"data"和"linelists"子文件夹中的Excel工作簿的第一张工作表(使用`here() `构建的文件路径):
```{r, eval=F}
linelist <- import(here("data", "linelists", "linelist_cleaned.xlsx"))
```


Importing a data frame (a .rds file) using an absolute file path:

使用绝对文件路径导入数据帧(.rds文件):

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds")
```





### Specific Excel sheets {.unnumbered}

By default, if you provide an Excel workbook (.xlsx) to `import()`, the workbook's first sheet will be imported. If you want to import a specific **sheet**, include the sheet name to the `which = ` argument. For example:  

默认情况下，如果您为` import()`提供一个Excel工作簿(.xlsx)，工作簿的第一个工作表将被导入。如果您想要导入一个特定的**工作表**，请将工作表名称包含到` which = `参数中。例如:

```{r eval=F}
my_data <- import("my_excel_file.xlsx", which = "Sheetname")
```

If using the `here()` method to provide a relative pathway to `import()`, you can still indicate a specific sheet by adding the `which = ` argument after the closing parentheses of the `here()` function.  

如果使用`here() `方法来提供通往` import() `的相对路径，您仍然可以通过在` here() `函数的圆括号后添加`which = `参数来指示特定的工作表。

```{r import_sheet_here, eval=F}
# Demonstration: importing a specific Excel sheet when using relative pathways with the 'here' package
linelist_raw <- import(here("data", "linelist.xlsx"), which = "Sheet1")`  
```

To *export* a data frame from R to a specific Excel sheet and have the rest of the Excel workbook remain unchanged, you will have to import, edit, and export with an alternative package catered to this purpose such as **openxlsx**. See more information in the page on [Directory interactions] or [at this github page](https://ycphs.github.io/openxlsx/).

要将数据框架从R导出到特定的Excel表格，并保持Excel工作簿的其余部分不变，您必须使用另一个包(如**openxlsx**)进行导入、编辑和导出。在[目录交互]页面或[在这个github页面](https://ycphs.github.io/openxlsx/)查看更多信息。

If your Excel workbook is .xlsb (binary format Excel workbook) you may not be able to import it using **rio**. Consider re-saving it as .xlsx, or using a package like **readxlsb** which is built for [this purpose](https://cran.r-project.org/web/packages/readxlsb/vignettes/read-xlsb-workbook.html).  

如果您的Excel工作簿是.xlsb(二进制格式的Excel工作簿)，您可能无法使用**rio**导入它。考虑将其重新保存为.xlsx，或者使用为[此目的]构建的**readxlsb**包(https://cran.r-project.org/web/packages/readxlsb/vignettes/read-xlsb-workbook.html)。




<!-- ======================================================= -->
### Missing values {#import_missing .unnumbered} 

You may want to designate which value(s) in your dataset should be considered as missing. As explained in the page on [Missing data], the value in R for missing data is `NA`, but perhaps the dataset you want to import uses 99, "Missing", or just empty character space "" instead.  

您可能希望指定您的数据集中哪些值应该被认为是缺失的。正如在[丢失的数据]的页面上解释的，在R中的值为丢失的数据是' NA '，但也许你想要导入的数据集使用99，"Missing"，或只是空字符空间""代替。

Use the `na = ` argument for `import()` and provide the value(s) within quotes (even if they are numbers). You can specify multiple values by including them within a vector, using `c()` as shown below.  

在`import() `中使用` na = `参数，并在引号中提供值(即使它们是数字)。可以使用` c() `在vector中指定多个值，如下所示。

Here, the value "99" in the imported dataset is considered missing and converted to `NA` in R.

在这里，被导入的数据集中的值“99”被认为丢失了，并被转换为R中的`NA`。

```{r, eval=F}
linelist <- import(here("data", "my_linelist.xlsx"), na = "99")
```

Here, any of the values "Missing", "" (empty cell), or " " (single space) in the imported dataset are converted to `NA` in R.  

在这里，任何值"Missing"， ""(空单元格)，或""(单个空格)在导入的数据集转换为`NA`在R。

```{r, eval=F}
linelist <- import(here("data", "my_linelist.csv"), na = c("Missing", "", " "))
```


<!-- ======================================================= -->
### Skip rows {.unnumbered} 

Sometimes, you may want to avoid importing a row of data. You can do this with the argument `skip = ` if using `import()` from **rio** on a .xlsx or .csv file. Provide the number of rows you want to skip. 

有时，您可能希望避免导入一行数据。如果在.xlsx或.csv文件上使用`import()`from **rio**，你可以使用参数' skip = '来实现这一点。提供要跳过的行数。


```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx", skip = 1)  # does not import header row
```

Unfortunately `skip = ` only accepts one integer value, *not* a range (e.g. "2:10" does not work). To skip import of specific rows that are not consecutive from the top, consider importing multiple times and using `bind_rows()` from **dplyr**. See the example below of skipping only row 2.  

不幸的是' skip = '只接受一个整数值，*而不是*一个范围(例如。“2:10”不行)。要跳过不从顶部连续导入的特定行，请考虑多次导入并使用**dplyr**中的`bind_rows()`。参见下面只跳过第2行的示例。


### Manage a second header row {.unnumbered}  

Sometimes, your data may have a *second* row, for example if it is a "data dictionary" row as shown below. This situation can be problematic because it can result in all columns being imported as class "character".  

有时，您的数据可能有*second*行，例如，如果它是“数据字典”行，如下所示。这种情况可能会有问题，因为它可能导致所有列都被导入为类“character”。

```{r, echo=F}
# HIDDEN FROM READER
####################
# Create second header row of "data dictionary" and insert into row 2. Save as new dataframe.
linelist_2headers <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) %>%         
        mutate(across(everything(), as.character)) %>% 
        add_row(.before = 1,
                #row_num = "000",
                case_id = "case identification number assigned by MOH",
                generation = "transmission chain generation number",
                date_infection = "estimated date of infection, mm/dd/yyyy",
                date_onset = "date of symptom onset, YYYY-MM-DD",
                date_hospitalisation = "date of initial hospitalization, mm/dd/yyyy",
                date_outcome = "date of outcome status determination",
                outcome = "either 'Death' or 'Recovered' or 'Unknown'",
                gender = "either 'm' or 'f' or 'unknown'",
                hospital = "Name of hospital of first admission",
                lon = "longitude of residence, approx",
                lat = "latitude of residence, approx",
                infector = "case_id of infector",
                source = "context of known transmission event",
                age = "age number",
                age_unit = "age unit, either 'years' or 'months' or 'days'",
                fever = "presence of fever on admission, either 'yes' or 'no'",
                chills = "presence of chills on admission, either 'yes' or 'no'",
                cough = "presence of cough on admission, either 'yes' or 'no'",
                aches = "presence of aches on admission, either 'yes' or 'no'",
                vomit = "presence of vomiting on admission, either 'yes' or 'no'",
                time_admission = "time of hospital admission HH:MM")
```

Below is an example of this kind of dataset (with the first row being the data dictionary).  

下面是此类数据集的一个示例(第一行是数据字典)。
```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist_2headers, 5), rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```

#### Remove the second header row {.unnumbered}  

To drop the second header row, you will likely need to import the data twice. 

要删除第二个标题行，您可能需要导入两次数据。

1) Import the data in order to store the correct column names  
2) Import the data again, skipping the first *two* rows (header and second rows)  
3) Bind the correct names onto the reduced dataframe

1） 导入数据以存储正确的列名
2） 再次导入数据，跳过前* 2 *行(标题和第二行)
3） 将正确的名称绑定到缩减的数据帧上

The exact argument used to bind the correct column names depends on the type of data file (.csv, .tsv, .xlsx, etc.). This is because **rio** is using a different function for the different file types (see table above).  

用于绑定正确列名的确切参数取决于数据文件的类型(.csv、.tsv、.xlsx等)。这是因为**里约热内卢**为不同的文件类型使用了不同的函数(参见上表)。

**For Excel files:** (`col_names = `)  

**对于Excel文件:** (' col_names = ')

```{r, eval=F}
# import first time; store the column names
linelist_raw_names <- import("linelist_raw.xlsx") %>% names()  # save true column names

# import second time; skip row 2, and assign column names to argument col_names =
linelist_raw <- import("linelist_raw.xlsx",
                       skip = 2,
                       col_names = linelist_raw_names
                       ) 
```

**For CSV files:** (`col.names = `)  

**对于CSV文件:** (' col.names = ')

```{r, eval=F}
# import first time; sotre column names
linelist_raw_names <- import("linelist_raw.csv") %>% names() # save true column names

# note argument for csv files is 'col.names = '
linelist_raw <- import("linelist_raw.csv",
                       skip = 2,
                       col.names = linelist_raw_names
                       ) 
```

**Backup option** - changing column names as a separate command

**备份选项** -更改列名作为一个单独的命令

```{r, eval=F}
# assign/overwrite headers using the base 'colnames()' function
colnames(linelist_raw) <- linelist_raw_names
```


#### Make a data dictionary {.unnumbered}  

Bonus! If you do have a second row that is a data dictionary, you can easily create a proper data dictionary from it. This tip is adapted from this [post](https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/).  

奖金!如果您确实有第二行是数据字典，那么您可以很容易地从中创建一个合适的数据字典。这条建议摘自这篇文章(https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/)。


```{r}
dict <- linelist_2headers %>%             # begin: linelist with dictionary as first row
  head(1) %>%                             # keep only column names and first dictionary row                
  pivot_longer(cols = everything(),       # pivot all columns to long format
               names_to = "Column",       # assign new column names
               values_to = "Description")
```


```{r message=FALSE, echo=F}
DT::datatable(dict, rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```



#### Combine the two header rows {.unnumbered}  

In some cases when your raw dataset has *two* header rows (or more specifically, the 2nd row of data is a secondary header), you may want to "combine" them or add the values in the second header row into the first header row.  

在某些情况下，当你的原始数据集有*两个*标题行(或更具体地说，第二行数据是一个二级标题)，你可能想要“合并”他们或添加值在第二个标题行到第一个标题行。

The command below will define the data frame's column names as the combination (pasting together) of the first (true) headers with the value immediately underneath (in the first row).  

下面的命令将把数据帧的列名定义为第一个(true)标题的组合(粘贴在一起)，该值直接位于下面(第一行)。

```{r, eval=F}
names(my_data) <- paste(names(my_data), my_data[1, ], sep = "_")
```



<!-- ======================================================= -->
### Google sheets {.unnumbered}

You can import data from an online Google spreadsheet with the **googlesheet4** package and by authenticating your access to the spreadsheet.  


您可以使用**googlesheet4**包从在线谷歌电子表格导入数据，并通过验证您对电子表格的访问。

```{r, eval=F}
pacman::p_load("googlesheets4")
```

Below, a demo Google sheet is imported and saved. This command may prompt confirmation of authentification of your Google account. Follow prompts and pop-ups in your internet browser to grant Tidyverse API packages permissions to edit, create, and delete your spreadsheets in Google Drive.  

下面，一个演示谷歌表被导入并保存。此命令可能提示确认您的谷歌帐户的身份验证。按照提示和弹出在您的互联网浏览器授予Tidyverse API包的权限来编辑，创建和删除您的电子表格在谷歌驱动器。


The sheet below is "viewable for anyone with the link" and you can try to import it. 

下面的表格是“任何人都可以看到的链接”，你可以尝试导入它。

```{r, eval=F}
Gsheets_demo <- read_sheet("https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0")
```

The sheet can also be imported using only the sheet ID, a shorter part of the URL:  

工作表也可以只使用工作表ID导入，URL的较短部分:

```{r, eval=F}
Gsheets_demo <- read_sheet("1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY")
```


Another package, **googledrive** offers useful functions for writing, editing, and deleting Google sheets. For example, using the  `gs4_create()` and `sheet_write()` functions found in this package. 

另一个包，**googledrive**提供有用的功能，编写，编辑和删除谷歌表。例如，使用这个包中的' gs4_create() '和' sheet_write() '函数。

Here are some other helpful online tutorials:  
[basic Google sheets importing tutorial](https://arbor-analytics.com/post/getting-your-data-into-r-from-google-sheets/)  
[more detailed tutorial](https://googlesheets4.tidyverse.org/articles/googlesheets4.html)  
[interaction between the googlesheets4 and tidyverse](https://googlesheets4.tidyverse.org/articles/articles/drive-and-sheets.html)  

以下是一些其他有用的在线教程:
[基本谷歌表单导入教程](https://arbor-analytics.com/post/getting-your-data-into-r-from-google-sheets/)
(更详细的教程)(https://googlesheets4.tidyverse.org/articles/googlesheets4.html)
[googlesheets4和tidyverse之间的互动](https://googlesheets4.tidyverse.org/articles/articles/drive-and-sheets.html)




## Multiple files - import, export, split, combine  

See the page on [Iteration, loops, and lists] for examples of how to import and combine multiple files, or multiple Excel workbook files. That page also has examples on how to split a data frame into parts and export each one separately, or as named sheets in an Excel workbook.  

有关如何导入和组合多个文件或多个Excel工作簿文件的示例，请参阅[Iteration, loops, and lists]页面。该页面还提供了一些示例，说明如何将数据框架分割成多个部分，然后分别导出每个部分，或者在Excel工作簿中导出指定的工作表。


<!-- ======================================================= -->
## Import from Github {#import_github}

Importing data directly from Github into R can be very easy or can require a few steps - depending on the file type. Below are some approaches:  

直接从Github导入数据到R可能非常简单，也可能需要一些步骤——这取决于文件类型。以下是一些方法:

### CSV files {.unnumbered}  

It can be easy to import a .csv file directly from Github into R with an R command.  

使用R命令可以很容易地从Github直接导入.csv文件到R中。

1) Go to the Github repo, locate the file of interest, and click on it  
3) Click on the "Raw" button (you will then see the "raw" csv data, as shown below)  
4) Copy the URL (web address)  
5) Place the URL in quotes within the `import()` R command  

1）到Github repo，找到感兴趣的文件，然后点击它
2）点击“Raw”按钮(您将看到“Raw”csv数据，如下所示)
3）复制网址(网址)
4）将URL放在' import() ' R命令中的引号中


```{r, out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_csv_raw.png"))
```

### XLSX files {.unnumbered}  

You may not be able to view the "Raw" data for some files (e.g. .xlsx, .rds, .nwk, .shp)  

您可能无法查看某些文件的“原始”数据(例如.xlsx， .rds， .nwk， .shp)

1) Go to the Github repo, locate the file of interest, and click on it  
2) Click the "Download" button, as shown below  
3) Save the file on your computer, and import it into R  

1)去Github repo，找到感兴趣的文件，并点击它
2)点击“下载”按钮，如下图所示
3)将文件保存在电脑上，并导入R

```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_xlsx.png"))
```

### Shapefiles {.unnumbered} 

Shapefiles have many sub-component files, each with a different file extention. One file will have the ".shp" extension, but others may have ".dbf", ".prj", etc.  To download a shapefile from Github, you will need to download each of the sub-component files individually, and save them in the *same* folder on your computer. In Github, click on each file individually and download them by clicking on the "Download" button.  

Shapefiles有许多子组件文件，每个子组件文件都有不同的文件扩展名。一个文件将有。Shp“扩展，但别人可能有”。dbf”、“。撮合下”,等等。要从Github下载shapefile，你需要单独下载每个子组件文件，并将它们保存在电脑上的*相同*文件夹中。在Github中，分别点击每个文件并通过点击“下载”按钮下载它们。

Once saved to your computer you can import the shapefile as shown in the [GIS basics] page using `st_read()` from the **sf** package. You only need to provide the filepath and name of the ".shp" file - as long as the other related files are within the same folder on your computer. 

一旦保存到您的计算机，您可以从**sf**包中使用' st_read() '导入如图[GIS基础]页所示的shapefile。您只需要提供的文件路径和名称。Shp "文件-只要其他相关文件在您的计算机上的同一文件夹。

Below, you can see how the shapefile "sle_adm3" consists of many files - each of which must be downloaded from Github.

下面，你可以看到shapefile“sle_adm3”是如何由许多文件组成的——每个文件都必须从Github下载。

```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_shp.png"))
```





<!-- ======================================================= -->
## Manual data entry {}

### Entry by rows {.unnumbered}  

Use the `tribble` function from the **tibble** package from the tidyverse ([online tibble reference](https://tibble.tidyverse.org/reference/tribble.html)).  
使用tidyverse ([online tibble reference](https://tibble.tidyverse.org/reference/tribble.html))中的**tibble**包中的`tribble`函数。

Note how column headers start with a *tilde* (`~`).  Also note that each column must contain only one class of data (character, numeric, etc.). You can use tabs, spacing, and new rows to make the data entry more intuitive and readable. Spaces do not matter between values, but each row is represented by a new line of code. For example:  

请注意，列头文件以*波浪号*(' ~ ')开头。还要注意，每一列必须只包含一类数据(字符、数字等)。您可以使用制表符、空格和新行来使数据条目更加直观和可读。值之间的空格不重要，但每一行都由一行新代码表示。例如:

```{r import_manual_row}
# create the dataset manually by row
manual_entry_rows <- tibble::tribble(
  ~colA, ~colB,
  "a",   1,
  "b",   2,
  "c",   3
  )
```

And now we display the new dataset:  

现在我们显示新的数据集:

```{r, echo=F}
# display the new dataset
DT::datatable(manual_entry_rows)
```


### Entry by columns {.unnumbered}  

Since a data frame consists of vectors (vertical columns), the **base** approach to manual dataframe creation in R expects you to define each column and then bind them together. This can be counter-intuitive in epidemiology, as we usually think about our data in rows (as above). 

由于数据帧由向量(垂直列)组成，在R中手动创建数据帧的**base**方法要求您定义每一列，然后将它们绑定在一起。这在流行病学中可能是违反直觉的，因为我们通常认为我们的数据是成行的(如上所述)。

```{r import_manual_col}
# define each vector (vertical column) separately, each with its own name
PatientID <- c(235, 452, 778, 111)
Treatment <- c("Yes", "No", "Yes", "Yes")
Death     <- c(1, 0, 1, 0)
```

<span style="color: orange;">**_CAUTION:_** All vectors must be the same length (same number of values).</span>

<span style="color: orange;">**_CAUTION:_**所有向量必须是相同的长度(相同数量的值)。</span>

The vectors can then be bound together using the function `data.frame()`:  

然后可以使用函数`data.frame()`将这些向量绑定在一起:

```{r}
# combine the columns into a data frame, by referencing the vector names
manual_entry_cols <- data.frame(PatientID, Treatment, Death)
```

And now we display the new dataset:  

现在我们显示新的数据集:

```{r, echo=F}
# display the new dataset
DT::datatable(manual_entry_cols)
```




### Pasting from clipboard {.unnumbered}  

If you copy data from elsewhere and have it on your clipboard, you can try one of the two ways below:  

如果你从别处复制数据并把它放在剪贴板上，你可以尝试以下两种方法之一:

From the **clipr** package, you can use `read_clip_tbl()` to import as a data frame, or just just `read_clip()` to import as a character vector. In both cases, leave the parentheses empty.

在**clipr**包中，你可以使用' read_clip_tbl() '作为数据帧导入，或者直接使用' read_clip() '作为字符向量导入。在这两种情况下，括号都为空。

```{r, eval=F}
linelist <- clipr::read_clip_tbl()  # imports current clipboard as data frame
linelist <- clipr::read_clip()      # imports as character vector
```
You can also easily export to your system's clipboard with **clipr**. See the section below on Export.  

您还可以轻松地导出到您的系统的剪贴板与**clipr**。请参阅下面关于导出的部分。


Alternatively, you can use the the `read.table()` function from **base** R with `file = "clipboard")` to import as a data frame:  
或者，你可以使用**base** R中的' read.table() '函数和' file = "clipboard") '来导入数据帧:

```{r, eval=F}
df_from_clipboard <- read.table(
  file = "clipboard",  # specify this as "clipboard"
  sep = "t",           # separator could be tab, or commas, etc.
  header=TRUE)         # if there is a header row
```






## Import most recent file  

Often you may receive daily updates to your datasets. In this case you will want to write code that imports the most recent file. Below we present two ways to approach this: 

通常情况下，您可能会收到您的数据集的每日更新。在这种情况下，您将希望编写代码来导入最近的文件。下面我们介绍两种方法:

* Selecting the file based on the date in the file name  
* Selecting the file based on file metadata (last modification)  

*根据文件名中的日期选择文件
*根据文件元数据(最后一次修改)选择文件

### Dates in file name {.unnumbered}  

This approach depends on three premises:  

这种方法依赖于三个前提:

1) You trust the dates in the file names  
2) The dates are numeric and appear in *generally* the same format (e.g. year then month then day)  
3) There are no other numbers in the file name  

1)你信任文件名中的日期
2)日期是数字的，并且以*一般*相同的格式出现(例如年，月，日)
3)文件名中没有其他数字

We will explain each step, and then show you them combined at the end.  

我们将解释每个步骤，然后在最后向您展示它们的组合。

First, use `dir()` from **base** R to extract just the file names for each file in the folder of interest. See the page on [Directory interactions] for more details about `dir()`. In this example, the folder of interest is the folder "linelists" within the folder "example" within "data" within the R project. 

首先，使用`dir()` from **base** R来提取文件夹中每个文件的文件名。有关' dir() '的详细信息，请参阅[目录交互]页面。在本例中，感兴趣的文件夹是R项目“data”中的“example”文件夹中的“linelists”文件夹。

```{r}
linelist_filenames <- dir(here("data", "example", "linelists")) # get file names from folder
linelist_filenames                                              # print
```

Once you have this vector of names, you can extract the dates from them by applying `str_extract()` from **stringr** using this regular expression. It extracts any numbers in the file name (including any other characters in the middle such as dashes or slashes). You can read more about **stringr** in the [Strings and characters] page.  

一旦你有了这个名称向量，你就可以通过使用这个正则表达式从**stringr**应用' str_extract() '从它们中提取日期。它提取文件名中的任何数字(包括中间的任何其他字符，如破折号或斜杠)。您可以在[字符串和字符]页中阅读关于**stringr**的更多信息。

```{r}
linelist_dates_raw <- stringr::str_extract(linelist_filenames, "[0-9].*[0-9]") # extract numbers and any characters in between
linelist_dates_raw  # print
```

Assuming the dates are written in generally the same date format (e.g. Year then Month then Day) and the years are 4-digits, you can use **lubridate**'s flexible conversion functions (`ymd()`, `dmy()`, or `mdy()`) to convert them to dates. For these functions, the dashes, spaces, or slashes do not matter, only the order of the numbers. Read more in the [Working with dates] page. 

假设日期通常以相同的日期格式(例如，年，月，日)写，年份是4位数字，你可以使用**润滑**灵活的转换函数(' ymd() '， ' dmy() '，或' mdy() ')将它们转换为日期。对于这些函数，破折号、空格或斜杠都不重要，只有数字的顺序。更多信息请参阅[使用日期]一页。

```{r}
linelist_dates_clean <- lubridate::ymd(linelist_dates_raw)
linelist_dates_clean
```


The **base** R function `which.max()` can then be used to return the index position (e.g. 1st, 2nd, 3rd, ...) of the maximum date value. The latest file is correctly identified as the 6th file - "case_linelist_2020-10-08.xlsx".  

然后，**base** R函数' which.max() '可用于返回最大日期值的索引位置(例如第1、2、3，…)。最新的文件被正确识别为第6个文件“case_linelist_2020-10-08.xlsx”。

```{r}
index_latest_file <- which.max(linelist_dates_clean)
index_latest_file
```

If we condense all these commands, the complete code could look like below. Note that the `.` in the last line is a placeholder for the piped object at that point in the pipe sequence. At that point the value is simply the number 6. This is placed in double brackets to extract the 6th element of the vector of file names produced by `dir()`.    

如果我们压缩所有这些命令，完整的代码如下所示。注意'。'是管道对象在管道序列中该点的占位符。在这一点上，数值就是数字6。它被放在双括号中以提取' dir() '生成的文件名向量的第6个元素。

```{r}
# load packages
pacman::p_load(
  tidyverse,         # data management
  stringr,           # work with strings/characters
  lubridate,         # work with dates
  rio,               # import / export
  here,              # relative file paths
  fs)                # directory interactions

# extract the file name of latest file
latest_file <- dir(here("data", "example", "linelists")) %>%  # file names from "linelists" sub-folder          
  str_extract("[0-9].*[0-9]") %>%                  # pull out dates (numbers)
  ymd() %>%                                        # convert numbers to dates (assuming year-month-day format)
  which.max() %>%                                  # get index of max date (latest file)
  dir(here("data", "example", "linelists"))[[.]]              # return the filename of latest linelist

latest_file  # print name of latest file
```

You can now use this name to finish the relative file path, with `here()`:  

现在你可以使用这个名称来完成相对文件路径，使用`here()`:
```{r, eval=F}
here("data", "example", "linelists", latest_file) 
```

And you can now import the latest file:  

现在你可以导入最新的文件:

```{r, eval=F}
# import
import(here("data", "example", "linelists", latest_file)) # import 
```

 



### Use the file info {.unnumbered}  

If your files do not have dates in their names (or you do not trust those dates), you can try to extract the last modification date from the file metadata. Use functions from the package **fs** to examine the metadata information for each file, which includes the last modification time and the file path.  

如果您的文件名称中没有日期(或者您不相信这些日期)，您可以尝试从文件元数据中提取最后一次修改日期。使用包**fs**中的函数检查每个文件的元数据信息，其中包括最后修改时间和文件路径。

Below, we provide the folder of interest to **fs**'s `dir_info()`. In this case, the folder of interest is in the R project in the folder "data", the sub-folder "example", and its sub-folder "linelists".  The result is a data frame with one line per file and columns for `modification_time`, `path`, etc. You can see a visual example of this in the page on [Directory interactions].    

下面，我们为**fs**'s ' dir_info() '提供感兴趣的文件夹。在本例中，感兴趣的文件夹位于R项目的文件夹“data”中，子文件夹“example”及其子文件夹“linelists”中。结果是一个数据帧，每个文件一行，列有' modification_time '， ' path '等。您可以在[目录交互]页面中看到一个可视化的示例。


We can sort this data frame of files by the column `modification_time`, and then keep only the top/latest row (file) with **base** R's `head()`. Then we can extract the file path of this latest file only with the **dplyr** function `pull()` on the column `path`. Finally we can pass this file path to `import()`. The imported file is saved as `latest_file`.  

我们可以通过' modification_time '列对文件的数据帧进行排序，然后使用**base** R的' head() '只保留最顶端/最近的行(文件)。然后，我们只能使用**dplyr**函数' pull() '对列' path '提取最新文件的文件路径。最后，我们可以将这个文件路径传递给' import() '。导入的文件保存为' latest_file '。

```{r, eval=F}
latest_file <- dir_info(here("data", "example", "linelists")) %>%  # collect file info on all files in directory
  arrange(desc(modification_time)) %>%      # sort by modification time
  head(1) %>%                               # keep only the top (latest) file
  pull(path) %>%                            # extract only the file path
  import()                                  # import the file

```



<!-- ======================================================= -->
## APIs {#import_api}

An "Automated Programming Interface" (API) can be used to directly request data from a website. APIs are a set of rules that allow one software application to interact with another. The client (you) sends a "request" and receives a "response" containing content. The R packages **httr** and **jsonlite** can facilitate this process. 

“自动编程接口”(API)可以用来直接从网站请求数据。api是一组允许一个软件应用程序与另一个软件应用程序交互的规则。客户端(您)发送一个“请求”并接收一个包含内容的“响应”。R包**httr**和**jsonlite**可以促进这个过程。

Each API-enabled website will have its own documentation and specifics to become familiar with. Some sites are publicly available and can be accessed by anyone. Others, such as platforms with user IDs and credentials, require authentication to access their data. 

每个支持api的网站都有自己的文档和细节需要熟悉。有些网站是公开的，任何人都可以访问。其他平台，如具有用户id和凭据的平台，需要身份验证才能访问其数据。

Needless to say, it is necessary to have an internet connection to import data via API. We will briefly give examples of use of APIs to import data, and link you to further resources.  

不用说，通过API导入数据需要有一个互联网连接。我们将简要地给出使用api导入数据的示例，并将您链接到进一步的资源。

*Note: recall that data may be *posted* on a website without an API, which may be easier to retrieve. For example a posted CSV file may be accessible simply by providing the site URL to `import()` as described in the section on [importing from Github](#import_github).*  

*注意:请记住，数据可能是在没有API的网站上发布的，这可能更容易检索。例如，一个发布的CSV文件可以通过简单地提供网站URL到' import() '来访问，这在[import from Github](#import_github)一节中描述


### HTTP request {.unnumbered}  

The API exchange is most commonly done through an HTTP request. HTTP is Hypertext Transfer Protocol, and is the underlying format of a request/response between a client and a server. The exact input and output may vary depending on the type of API but the process is the same - a "Request" (often HTTP Request) from the user, often containing a query, followed by a "Response", containing status information about the request and possibly the requested content.  

API交换最常通过HTTP请求完成。HTTP是超文本传输协议，是客户端和服务器之间请求/响应的基本格式。确切的输入和输出可能取决于API的类型，但过程是相同的——来自用户的一个“请求”(通常是HTTP请求)，通常包含一个查询，后面是一个“响应”，包含关于请求的状态信息和可能被请求的内容。

Here are a few components of an *HTTP request*: 

下面是一个*HTTP请求的几个组件:

* The URL of the API endpoint  
* The "Method" (or "Verb")  
* Headers  
* Body  

* API端点的URL
*“方法”(或“动词”)
*标题
*身体

The HTTP request "method" is the action your want to perform. The two most common HTTP methods are `GET` and `POST` but others could include `PUT`, `DELETE`, `PATCH`, etc. When importing data into R it is most likely that you will use `GET`.  

：HTTP请求“方法”是您想要执行的操作。两个最常见的HTTP方法是' GET '和' POST '，但其他的可能包括`PUT`， `DELETE`， `PATCH`等。当将数据导入R时，您很可能会使用`GET`。

After your request, your computer will receive a "response" in a format similar to what you sent, including URL, HTTP status (Status 200 is what you want!), file type, size, and the desired content. You will then need to parse this response and turn it into a workable data frame within your R environment.

在您的请求之后，您的计算机将收到与您发送的格式相似的“响应”，包括URL、HTTP状态(状态200就是您想要的!)、文件类型、大小和想要的内容。然后需要解析这个响应，并将其转换为R环境中可行的数据帧。


### Packages {.unnumbered}  

The **httr** package works well for handling HTTP requests in R. It requires little prior knowledge of Web APIs and can be used by people less familiar with software development terminology. In addition, if the HTTP response is .json, you can use **jsonlite** to parse the response.  

** HTTP **包可以很好地处理r中的HTTP请求。它不需要太多的Web api知识，并且可以被不太熟悉软件开发术语的人使用。此外，如果HTTP响应是.json，您可以使用**jsonlite**来解析响应。

```{r, eval=F}
# load packages
pacman::p_load(httr, jsonlite, tidyverse)
```


### Publicly-available data {.unnumbered}  

Below is an example of an HTTP request, borrowed from a tutorial from [the Trafford Data Lab](https://www.trafforddatalab.io/open_data_companion/#A_quick_introduction_to_APIs). This site has several other resources to learn and API exercises.

下面是一个HTTP请求的例子，借鉴自[特拉福德数据实验室](https://www.trafforddatalab.io/open_data_companion/#A_quick_introduction_to_APIs)的教程。这个站点有一些其他的学习资源和API练习

Scenario: We want to import a list of fast food outlets in the city of Trafford, UK. The data can be accessed from the API of the Food Standards Agency, which provides food hygiene rating data for the United Kingdom.  

场景:我们想要进口英国特拉福德市的快餐店列表。这些数据可以从英国食品标准局的API获取，该机构为英国提供食品卫生评级数据。

Here are the parameters for our request:  

以下是我们要求的参数:

* HTTP verb: GET  
* API endpoint URL: http://api.ratings.food.gov.uk/Establishments  
* Selected parameters: name, address, longitude, latitude, businessTypeId, ratingKey, localAuthorityId  
* Headers: “x-api-version”, 2  
* Data format(s): JSON, XML  
* Documentation: http://api.ratings.food.gov.uk/help  

* HTTP动词:GET
* API端点URL: http://api.ratings.food.gov.uk/Establishments
* 可选参数:名称、地址、经度、纬度、businessstypeid、ratingKey、localAuthorityId
* 报头:" x-api-version "， 2
* 数据格式:JSON、XML
* 文档:http://api.ratings.food.gov.uk/help进入翻译页面

The R code would be as follows:  

R代码如下:

```{r, eval=F, warning=F, message=F}
# prepare the request
path <- "http://api.ratings.food.gov.uk/Establishments"
request <- GET(url = path,
             query = list(
               localAuthorityId = 188,
               BusinessTypeId = 7844,
               pageNumber = 1,
               pageSize = 5000),
             add_headers("x-api-version" = "2"))

# check for any server error ("200" is good!)
request$status_code

# submit the request, parse the response, and convert to a data frame
response <- content(request, as = "text", encoding = "UTF-8") %>%
  fromJSON(flatten = TRUE) %>%
  pluck("establishments") %>%
  as_tibble()
```

You can now clean and use the `response` data frame, which contains one row per fast food facility.  

现在可以清理和使用`response`数据帧，每个快餐设施包含一行。


### Authentication required {.unnumbered}  

Some APIs require authentication - for you to prove who you are, so you can access restricted data. To import these data, you may need to first use a POST method to provide a username, password, or code. This will return an access token, that can be used for subsequent GET method requests to retrieve the desired data.  

有些api需要身份验证—以便您证明您是谁，以便您可以访问受限制的数据。要导入这些数据，您可能需要首先使用POST方法来提供用户名、密码或代码。这将返回一个访问令牌，该令牌可用于后续的GET方法请求，以检索所需的数据。

Below is an example of querying data from *Go.Data*, which is an outbreak investigation tool. *Go.Data* uses an API for all interactions between the web front-end and smartphone applications used for data collection. *Go.Data* is used throughout the world. Because outbreak data are sensitive and you should only be able to access data for *your* outbreak, authentication is required.  

下面是一个从*Go查询数据的示例。Data*，这是一个爆发调查工具。*去。Data*使用一个API，用于web前端和用于数据收集的智能手机应用程序之间的所有交互。*去。全世界都在使用Data*。由于爆发数据是敏感的，您应该只能访问*您的*爆发的数据，因此需要身份验证。

Below is some sample R code using **httr** and **jsonlite** for connecting to the *Go.Data* API to import data on contact follow-up from your outbreak.  

下面是一些示例R代码使用**httr**和**jsonlite**连接到*Go。数据* API用于从您的病毒爆发导入有关联系人跟踪的数据。


```{r, eval=F}
# set credentials for authorization
url <- "https://godatasampleURL.int/"           # valid Go.Data instance url
username <- "username"                          # valid Go.Data username 
password <- "password"                          # valid Go,Data password 
outbreak_id <- "xxxxxx-xxxx-xxxx-xxxx-xxxxxxx"  # valid Go.Data outbreak ID

# get access token
url_request <- paste0(url,"api/oauth/token?access_token=123") # define base URL request

# prepare request
response <- POST(
  url = url_request,  
  body = list(
    username = username,    # use saved username/password from above to authorize                               
    password = password),                                       
    encode = "json")

# execute request and parse response
content <-
  content(response, as = "text") %>%
  fromJSON(flatten = TRUE) %>%          # flatten nested JSON
  glimpse()

# Save access token from response
access_token <- content$access_token    # save access token to allow subsequent API calls below

# import outbreak contacts
# Use the access token 
response_contacts <- GET(
  paste0(url,"api/outbreaks/",outbreak_id,"/contacts"),          # GET request
  add_headers(
    Authorization = paste("Bearer", access_token, sep = " ")))

json_contacts <- content(response_contacts, as = "text")         # convert to text JSON

contacts <- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # flatten JSON to tibble
```

<span style="color: orange;">**_CAUTION:_** If you are importing large amounts of data from an API requiring authentication, it may time-out. To avoid this, retrieve access_token again before each API GET request and try using filters or limits in the query. </span> 

<span style="color: orange;">** _warning:_**如果你从一个需要认证的API导入大量数据，它可能会超时。为了避免这种情况，请在每个API GET请求之前再次检索access_token，并尝试在查询中使用过滤器或限制。</span> 

<span style="color: darkgreen;">**_TIP:_** The `fromJSON()` function in the **jsonlite** package does not fully un-nest the first time it's executed, so you will likely still have list items in your resulting tibble. You will need to further un-nest for certain variables; depending on how nested your .json is. To view more info on this, view the documentation for the **jsonlite** package, such as the [`flatten()` function](https://rdrr.io/cran/jsonlite/man/flatten.html). </span>

<span style="color: darkgreen;"> **_TIP:_** ** *jsonlite**包中的' fromJSON() '函数在第一次执行时并没有完全解除嵌套，所以在生成的tibble中可能仍然有列表项。您需要进一步解除某些变量的嵌套;这取决于。json的嵌套程度。要查看更多信息，请查看**jsonlite**包的文档，比如[' flatten() ' function](https://rdrr.io/cran/jsonlite/man/flatten.html)。</span>


For more details, View documentation on [LoopBack Explorer](https://loopback.io/doc/en/lb4/index.html), the [Contact Tracing] page or API tips on [Go.Data Github repository](https://worldhealthorganization.github.io/godata/api-docs)

欲了解更多详情，请查看[LoopBack Explorer](https://loopback.io/doc/en/lb4/index.html)的文档，[联系人跟踪]页面或[Go]的API提示。数据Github库)(https://worldhealthorganization.github.io/godata/api-docs)

You can read more about the *httr* package [here](https://httr.r-lib.org/articles/quickstart.html) 

你可以阅读更多关于*httr* 包[这里](https://httr.r-lib.org/articles/quickstart.html)

This section was also informed by [this tutorial](https://www.dataquest.io/blog/r-api-tutorial/) and [this tutorial](https://medium.com/@traffordDataLab/querying-apis-in-r-39029b73d5f1). 

本节也由[本教程](https://www.dataquest.io/blog/r-api-tutorial/)和[本教程](https://medium.com/@traffordDataLab/ query-api -in-r-39029b73d5f1)提供。



<!-- ======================================================= -->
## Export {}  

### With **rio** package {.unnumbered}
With **rio**, you can use the `export()` function in a very similar way to `import()`. First give the name of the R object you want to save (e.g. `linelist`) and then in quotes put the file path where you want to save the file, including the desired file name and file extension. For example:

使用**rio**，您可以以非常类似的方式使用' export() '函数。首先给出要保存的R对象的名称(例如。' linelist ')，然后在引号中放置你想保存文件的文件路径，包括所需的文件名和文件扩展名。例如:

This saves the data frame `linelist` as an Excel workbook to the working directory/R project root folder:  

这将数据框架`lineelist` 作为Excel工作簿保存到工作目录/R项目根文件夹:

```{r, eval=F}
export(linelist, "my_linelist.xlsx") # will save to working directory
```

You could save the same data frame as a csv file by changing the extension. For example, we also save it to a file path constructed with `here()`:  

您可以通过更改扩展名将相同的数据帧保存为csv文件。例如，我们也将它保存到用' here() '构造的文件路径中:

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.csv"))
```


### To clipboard {.unnumbered}

To export a data frame to your computer's "clipboard" (to then paste into another software like Excel, Google Spreadsheets, etc.) you can use `write_clip()` from the **clipr** package. 

要将数据帧导出到计算机的“剪贴板”(然后粘贴到Excel、谷歌Spreadsheets等其他软件中)，可以使用**clipr**包中的' write_clip() '。

```{r, eval=F}
# export the linelist data frame to your system's clipboard
clipr::write_clip(linelist)
```




## RDS files {#import_rds}

Along with .csv, .xlsx, etc, you can also export/save R data frames as .rds files. This is a file format specific to R, and is very useful if you know you will work with the exported data again in R. 

除了.csv、.xlsx等，您还可以将R数据帧导出/保存为.rds文件。这是R特有的一种文件格式，如果您知道将在R中再次使用导出的数据，这将非常有用。

The classes of columns are stored, so you don't have do to cleaning again when it is imported (with an Excel or even a CSV file this can be a headache!). It is also a smaller file, which is useful for export and import if your dataset is large.  

列的类是存储的，所以在导入时不需要再次进行清理(对于Excel甚至是CSV文件，这可能是一个令人头痛的问题!)它也是一个较小的文件，如果您的数据集较大，这对于导出和导入非常有用。

For example, if you work in an Epidemiology team and need to send files to a GIS team for mapping, and they use R as well, just send them the .rds file! Then all the column classes are retained and they have less work to do.  

例如，如果你在一个流行病学小组工作，需要向一个GIS小组发送文件来绘制地图，而他们也使用R，那么就给他们发送。rds文件!然后保留所有的列类，它们需要做的工作更少。

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.rds"))
```



<!-- ======================================================= -->
## Rdata files and lists {#import_rdata}

`.Rdata` files can store multiple R objects - for example multiple data frames, model results, lists, etc. This can be very useful to consolidate or share a lot of your data for a given project.  


`.Rdata` 的文件可以存储多个R对象，例如多个数据帧、模型结果、列表等。这对于整合或共享给定项目的大量数据非常有用。

In the below example, multiple R objects are stored within the exported file "my_objects.Rdata":  

在下面的示例中，多个R对象存储在导出的文件“my_objects”中。Rdata”:

```{r, eval=F}
rio::export(my_list, my_dataframe, my_vector, "my_objects.Rdata")
```

Note: if you are trying to *import* a list, use `import_list()` from **rio** to import it with the complete original structure and contents.  

注意:如果你试图*导入*一个列表，使用' import_list() ' from **里约热内卢**来导入完整的原始结构和内容。

```{r, eval=F}
rio::import_list("my_list.Rdata")
```







<!-- ======================================================= -->
## Saving plots {} 

Instructions on how to save plots, such as those created by `ggplot()`, are discussed in depth in the [ggplot basics] page.  

关于如何保存图形(例如由' ggplot() '创建的图形)的说明，将在[ggplot basics]页面中进行深入讨论。

In brief, run `ggsave("my_plot_filepath_and_name.png")` after printing your plot. You can either provide a saved plot object to the `plot = ` argument, or only specify the destination file path (with file extension) to save the most recently-displayed plot. You can also control the `width = `, `height = `, `units = `, and `dpi = `.  

简单地说，在打印你的图形之后，运行' ggsave("my_plot_filepath_and_name.png") '。您可以为' plot = '参数提供一个已保存的plot对象，或者只指定保存最近显示的plot的目标文件路径(使用文件扩展名)。您还可以控制' width = '， ' height = '， ' units = '和' dpi = '。

How to save a network graph, such as a transmission tree, is addressed in the page on [Transmission chains]. 

如何保存网络图，如传输树，在[传输链]的页面中进行了说明。


<!-- ======================================================= -->
## Resources {} 

The [R Data Import/Export Manual](https://cran.r-project.org/doc/manuals/r-release/R-data.html)  

R数据导入/导出手册](https://cran.r-project.org/doc/manuals/r-release/R-data.html)

[R 4 Data Science chapter on data import](https://r4ds.had.co.nz/data-import.html#data-import)  
[ggsave() documentation](https://ggplot2.tidyverse.org/reference/ggsave.html)  

[R 4数据科学关于数据导入的章节](https://r4ds.had.co.nz/data-import.html#data-import)
[ggsave()的文档)(https://ggplot2.tidyverse.org/reference/ggsave.html)

Below is a table, taken from the **rio** online [vignette](https://cran.r-project.org/web/packages/rio/vignettes/rio.html). For each type of data it shows: the expected file extension, the package **rio** uses to import or export the data, and whether this functionality is included in the default installed version of **rio**.  

下面是一个表格，取自 **rio** online [vignette](https://cran.r-project.org/web/packages/rio/vignettes/rio.html)。对于每种类型的数据，它显示:预期的文件扩展名，包**rio**用于导入或导出数据，以及该功能是否包含在**rio**的默认安装版本中。


Format                     | Typical Extension | Import Package    | Export Package     | Installed by Default
---------------------------|-------------------|-------------------|--------------------|---------------------
Comma-separated data | .csv | data.table `fread()` | data.table |	Yes
Pipe-separated data |	.psv | data.table `fread()` | data.table | Yes
Tab-separated data| .tsv | data.table `fread()` | data.table | Yes
SAS | .sas7bdat | haven | haven | Yes
SPSS | .sav | haven | haven | Yes
Stata | .dta | haven | haven | Yes
SAS | XPORT | .xpt | haven | haven | Yes
SPSS Portable | .por | haven | | Yes
Excel | .xls | readxl | | Yes
Excel | .xlsx | readxl | openxlsx | Yes
R syntax | .R	| base | base | Yes
Saved R objects | .RData, .rda | base | base | Yes
Serialized R objects | .rds | base | base | Yes
Epiinfo | .rec | foreign | | Yes
Minitab | .mtp | foreign | | Yes
Systat | .syd |	foreign | | Yes
“XBASE” | database files | .dbf | foreign | foreign | Yes
Weka Attribute-Relation File Format | .arff | foreign | foreign | Yes
Data Interchange Format | .dif | utils | | Yes
Fortran data | no recognized extension | utils | | Yes
Fixed-width format data | .fwf | utils | utils | Yes
gzip comma-separated data | .csv.gz | utils | utils | Yes
CSVY (CSV + YAML metadata header) | .csvy | csvy | csvy | No
EViews | .wf1 |hexView | | No
Feather R/Python interchange format | .feather | feather | feather | No
Fast Storage | .fst | fst |	fst | No
JSON | .json | jsonlite | jsonlite | No
Matlab | .mat | rmatio | rmatio | No
OpenDocument Spreadsheet | .ods | readODS | readODS | No
HTML Tables | .html | xml2 | xml2 | No
Shallow XML documents | .xml | xml2 | xml2 | No
YAML | .yml | yaml | yaml	| No
Clipboard	default is tsv | |  clipr | clipr | No




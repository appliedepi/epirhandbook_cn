# 数据表

本指南侧重于使用 **dplyr** "verb" 函数和 **magrittr** 管道运算符 `%>%` 作为整理和分组数据的方法，但 **data.table** package 可以作为另一种可能被使用的方法。

<!-- ======================================================= -->

## 数据表简介

数据表是一种二维数据结构，类似于数据框，其允许执行复杂的分组操作。 data.table 语法的结构使得您可以对行、列和组执行操作。

数据表结构表达为 **DT[i, j, by]**,由 i, j 和 by 三个参数组成。 i 参数代表对行的操作， j 参数代表列的操作，而 by 参数允许您按组对列进行操作。

本页将讨论以下主题：

-   导入数据并且使用 `fread()` 和 `fwrite()`
-   使用 i 参数选择和过滤行
-   使用辅助函数`%like%`, `%chin%`, `%between%`
-   使用 j 参数选择和计算列
-   使用 by 参数按组计算数据
-   使用`:=` 向数据表添加和更新数据

<!-- ======================================================= -->

## 加载 packages 和导入数据

### 加载 packages {.unnumbered}

使用 **pacman** 中的 `p_load()` 函数，您可以加载（或者安装）此分析所需的 packages。.

```{r}
pacman::p_load(
  rio,        # 载入数据
  data.table, # 对数据进行分组和整理
  tidyverse,  # 允许使用管道 (%>%) 函数
  here 
  ) 
```

### 导入数据 {.unnumbered}

本页将使用整本指南中之前引用的行列表来探索 **data.table** 的一些核心功能。

我们从模拟的埃博拉疫情中导入病例数据集。 如果您想知道如何逐步地下载数据，请参阅 [下载书籍和数据] 页面中的说明。请您使用 **rio** 包中的`import()` 函数导入数据集。有关导入数据的不同方法，请参见 [导入和导出] 页面。 在这里我们使用 `data.table()` 将数据框转换为数据表。

```{r}
linelist <- rio::import(here("data", "linelist_cleaned.xlsx")) %>% data.table()
```

`fread()` 函数可用于将常规分隔文件（例如 .csv 文件）直接导入数据表格式。 此函数的对应函数 `fwrite()` 用于将 data.tables 写入常规分隔文件。对于大型数据库来说，这两个函数是非常快速且高效的选择。

`linelist` 的前 20 行：

```{r message=FALSE, echo=F, eval=FALSE}
DT::datatable(head(linelist,20), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

用于数据框的基本 R 命令（例如 `dim()`）也可用于数据表。

```{r}
dim(linelist) #显示数据表中的行数和列数
```

<!-- ======================================================= -->

## i 参数：选择和过滤行

回顾 **DT[i, j, by]** 结构，我们可以使用行号或逻辑表达式筛选行。 由于i 参数是第一个参数， 因此我们在表达时可以使用语法 **DT[i]** 或 **DT[i,]**。

第一个示例用于检索数据表的前 5 行，第二个示例选择了为 18 岁或以上的病例作为子集，第三个示例选择了 18 岁或以上但未在中心医院诊断的病例作为子集：

```{r, eval=F}
linelist[1:5] #返回第 1 到第 5 行
linelist[age >= 18] #18 岁或以上的病例作为子集
linelist[age >= 18 & hospital != "Central Hospital"] #18 岁或以上但未在中心医院诊断的病例作为子集

```

在 i 参数中使用 .N 表示数据表中的总行数。 这帮助您来选择特定子集：

```{r, eval=F}
linelist[.N] #返回最后一行
linelist[15:.N] #返回第 15 行到最后一行
```

### 使用辅助函数进行过滤 {.unnumbered}

数据表能够使用辅助函数，使过滤行变得更容易。 `%like%` 函数可用于匹配列中的特定模式，`%chin%` 用于匹配特定字符，`%between%` 辅助函数用于匹配预先指定范围内的数字列。

在以下示例中，我们：

\* 过滤医院变量包含"医院"的行

\* 过滤结果为"康复"或"死亡"的行

\* 过滤年龄范围 40-60 的行

```{r, eval=F}
linelist[hospital %like% "Hospital"] #过滤hospital变量包含“Hospital”的行
linelist[outcome %chin% c("Recover", "Death")] #过滤结果为“康复”或“死亡”的行 
linelist[age %between% c(40, 60)] #过滤年龄范围 40-60 的行 

#%between% 必须采用长度为 2 的向量, %chin% 可以采用长度 >= 1 的向量

```

## j 参数：选择和计算列

由于数据表是 **DT[i, j, by]** 结构，我们可以使用数字或名称来选择列。由于j 参数是第二个参数， 因此我们在表达时可以使用语法 **DT[, j]**。为了便于对 j 参数进行计算，列通常使用 `list()` 或`.()`进行包装。

### 选择列 {.unnumbered}

第一个示例用于检索数据表的第一列、第三列和第五列；第二个示例选择除身高、体重和性别列之外的所有列。 第三个示例使用 `.()`来选择 **case_id** 和 **outcome** 列。

The first example retrieves the first, third and fifth columns of the data table, the second example selects all columns except the height, weight and gender columns. The third example uses the `.()` wrap to select the **case_id** and **outcome** columns.

```{r, eval=F}
linelist[ , c(1,3,5)]
linelist[ , -c("gender", "age", "wt_kg", "ht_cm")]
linelist[ , list(case_id, outcome)] #linelist[ , .(case_id, outcome)] 也能正常工作

```

### 计算列 {.unnumbered}

通过组合使用 i 和 j 参数，您可以过滤行并计算列。 在 j 参数中使用**.N** 也表示数据表中的总行数，并且常用于过滤行后返回总行数。

在以下示例中，我们：

\* 统计住院超过 7 天的病例数

\* 计算在军队医院死亡的病例的平均年龄

\* 计算中心医院康复病例的标准差、中位数、平均年龄

```{r}
linelist[days_onset_hosp > 7 , .N]
linelist[hospital %like% "Military" & outcome %chin% "Death", .(mean(age, na.rm = T))] #na.rm = T removes N/A values
linelist[hospital == "Central Hospital" & outcome == "Recover", 
                 .(mean_age = mean(age, na.rm = T),
                   median_age = median(age, na.rm = T),
                   sd_age = sd(age, na.rm = T))] #此语法不使用辅助函数，但同样有效

```

请记住，在 j 参数中使用 .() 包裹列有助于计算、返回数据表并允许对列命名。

## by参数:按组计算

by 参数是 **DT[i, j, by]** 结构中的第三个参数。 by 参数中可以使用字符向量和`list()` 或 `.()` 语法。 在 by 参数中使用 `.()` 语法允许在运行中重命名列。

在下面的例子中，我们：\
\* 将病例数按医院分组

\*对于 18 岁或以上的病例，根据性别以及是否康复或死亡，计算病例的平均身高和体重

\* 在持续超过 入院7 天的病例中，根据入院月份和入院医院统计病例

```{r}
linelist[, .N, .(hospital)] #按医院分组的病例数
linelist[age > 18, .(mean_wt = mean(wt_kg, na.rm = T), mean_ht = mean(ht_cm, na.rm = T)), .(gender, outcome)] #NAs 代表数据缺失的类别
linelist[days_onset_hosp > 7, .N, .(month = month(date_hospitalisation), hospital)]`
```

    Data.table 还允许链接表达式如下：

```{r}
linelist[, .N, .(hospital)][order(-N)][1:3] #第一个子集按医院选择所有病例，第二个子集按降序排列病例，第三个子集是病例量最大的 3 家医院
```

在这些示例中，我们假设数据表中的一行等于一个新案例，因此我们可以使用 **.N** 来表示数据表中的行数。 表示唯一案例数量的另一个有用函数是 `uniqueN()`，它返回输入中唯一案例的数量。 这在此处进行了说明：

```{r}
linelist[, .(uniqueN(gender))] #记住 j 参数中的 .() 返回一个数据表
```

    答案是 3，因为性别列中的唯一值是 m、f 和 N/A。 与基本 R 函数 `unique()` 进行比较，后者返回给定输入中的所有唯一值：

```{r}
linelist[, .(unique(gender))]
```

要查找给定月份中唯一案例的数量，我们将编译以下代码：

```{r}
linelist[, .(uniqueN(case_id)), .(month = month(date_hospitalisation))]#添加和更新数据表
```

    :=`运算符用于在数据表中添加或更新数据。 您可以通过以下方式向数据表中添加列：

```{r}
linelist[, adult := age >= 18] #添加一列
linelist[, c("child", "wt_lbs") := .(age < 18, wt_kg*2.204)] #添加多个列需要 c("") 和 list() 或 .() 语法 
linelist[, `:=` (bmi_in_range = (bmi > 16 & bmi < 40),
          no_infector_source_data = is.na(infector) | is.na(source))] #t此方法使用 := 作为函数运算符 `:=`
linelist[, adult := NULL] #删除某列
```

更复杂的复合计算超出了本介绍性章节的范围，但其基本理念是为 **dplyr** 提供一种流行且可行的替代方案，用于分组和整理数据。 总的来说，**data.table** 是一个很棒的package ，它拥有整洁和可读性强的代码。

## 资料来源

以下是一些有助于获取更多信息的资源：

\* <https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html>

\* <https://github.com/Rdatatable/data.table>

\* <https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf>

\* <https://www.machinelearningplus.com/data-manipulation/datatable-in-r-complete-guide/>

\* <https://www.datacamp.com/community/tutorials/data-table-r-tutorial>

您可以在分组数据上使用任何汇总函数，请参阅此处的速查表以获取更多信息：

<https://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Sheet_R.pdf>

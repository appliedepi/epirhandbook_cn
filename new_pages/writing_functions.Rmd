# 创建函数

<!-- ======================================================= -->

## 准备

### 载入 packages {.unnumbered}

下述代码块显示了如何加载创建函数所需的packages。 在本指南中，我们主要使用 **pacman** 中的 `p_load()`，它会在必要时安装 package 并加载它以供用户使用。 您还可以使用来自 **base** R 的 `library()` 加载已安装的packages。有关 R packages 的更多信息，请参阅 [R 基础] 页面。

```{r, echo=F, warning=F, message=F}
pacman::p_load(
  rio,          # 文件导入
  here,         # 文件定位
  skimr,        # 数据总览
  tidyverse,    # 数据管理 + ggplot2 图形, 
  gtsummary,    # 汇总统计和测试
  janitor,      # 将总数和百分比添加到表格中
  scales,       # 更轻松地将比例转换为百分比
  flextable,     # 将表格转换为HTML
  purrr,          # 使函数的编程更容易
  readr,          # 读取 csv 文件
  highcharter     # 创建 highchart 并绘制特定的图表

  )
```

### 导入数据 {.unnumbered}

我们从模拟的埃博拉疫情中导入病例数据集。 如果您要逐步的下载数据，请参考 [下载书籍和数据] 页面中的说明。 数据集是使用 **rio** package中的 `import()` 函数导入的。 各种数据导入方式见 [导入和导出] 页面。

在本页的最后一部分，我们还将使用 2013 年 H7N9 流感的一些数据。

```{r, echo=F}
# 导入 linelists 到 R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

flu_china <- rio::import(here::here("data", "case_linelists", "fluH7N9_China_2013.csv"))

```

## 函数

函数在编程中很有帮助，因为它们可以让代码更容易被理解、更短、更不容易出错（如果函数本身没有错误的话）。

如果你已经阅读本指南到此章节，意味着你已经见到了无穷无尽的函数。因为在 R 中，每个操作都是一个函数调用 `+, for, if, [, $, { …`。 例如`x + y` 等同于 `'+'(x, y)` 。

R 是可以轻松使用函数并为用户提供足够工具来编写函数的语言之一。 我们不应该刻板地认为函数必须应用在编程代码的头部或末端，R 提供了将它们当作向量使用的可能性，甚至可以在其他函数、列表......中使用函数。

网上有很多关于函数编程的高级进阶资源。我们只会本页里提供一些启示，以帮助您通过简短的示例并能开始进行函数编程。之后，我们鼓励您访问参考文献以阅读更多相关信息。

## 为什么要使用函数？

在回答这个问题之前，更重要的是您已经在本手册的 [迭代、循环和列表] 页面中获得了编写第一个 R 函数的技巧。 事实上，"if/else"和循环的使用通常是我们许多函数的核心部分，因为它们很容易帮助我们将代码应用于多个情况之下或迭代代码以重复完成任务。

-   我需要多次重复相同的代码块以将其应用于不同的变量或数据？

-   整合部分代码会大大缩短我的整体代码并使其运行得更快吗？

-   我编写的代码是否有可能在改变了内部许多数值后再次使用？

如果您关于上述问题的答案中存在 "**是**" ，那么您可能需要编写一个函数。

## 如何在 R 中创建函数？

R 中的函数具有三个主要组成部分：

-   `formals()` - 控制我们如何调用函数的参数列表

-   `body()` - 函数内部的代码。在括号内或括号后，取决于我们如何编写它

和,

-   `environment()` - 用于定位函数的变量并规定函数如何找到值

创建函数后，您可以通过调用关联的函数来验证这些组件。

## 基本语法和结构

-   函数需要正确命名，这样我们一读到它的名字就很容易理解它的工作。 实际上，大多数 base R 函数就是正确命名的典型例子。 `mean()`, `print()`, `summary()` 等函数的名称非常简单。

-   函数需要参数，例如要处理的数据以及可以是静态值的其他对象。

-   最后，函数将根据其核心任务和给定的参数来产生输出。 通常我们会使用内置函数 `print()`, `return()`...来产生输出。 输出可以是一个逻辑值、一个数字、一个字符、一个数据框......简而言之，R 中任何类型的对象。

基本上，这是一个函数的组成：

```{r, eval=FALSE}

function_name <- function(argument_1, argument_2, argument_3){
  
           function_task
  
           return(output)
}


```

我们可以创建第一个名为 `contain_covid19()` 的函数。

```{r}

contain_covid19 <- function(barrier_gest, wear_mask, get_vaccine){
  
                            if(barrier_gest == "yes" & wear_mask == "yes" & get_vaccine == "yes" ) 
       
                            return("success")
  
  else("please make sure all are yes, this pandemic has to end!")
}


```

然后我们可以验证新创建的函数的组件。

```{r}

formals(contain_covid19)
body(contain_covid19)
environment(contain_covid19)

```

现在我们将测试我们的函数。 要调用我们编写的函数，您可以像使用所有 R 函数一样使用它，即通过编写函数名称并添加所需的参数。

```{r}

contain_covid19(barrier_gest = "yes", wear_mask = "yes", get_vaccine = "yes")

```

为了减少犯错，我们可以再次写下每个参数的名称。 但是即使没有重新写下名称，代码也可以工作。因为 R 存储了每个参数的位置。 所以只要你把参数的值按正确的顺序排列，你就可以在调用函数时不重复写参数名称。

```{r}

contain_covid19("yes", "yes", "yes")

```

接下来让我们看看如果其中一个值是`"no"`或不是`"yes"`会发生什么。

```{r}

contain_covid19(barrier_gest = "yes", wear_mask = "yes", get_vaccine = "no")
```

如果我们提供了一个无法识别的参数，我们会得到一个错误提醒：

```{r, eval=F}
contain_covid19(barrier_gest = "sometimes", wear_mask = "yes", get_vaccine = "no")
```

`Error in contain_covid19(barrier_gest = "sometimes", wear_mask = "yes",  :    could not find function "contain_covid19"`

[**注释:** 一些函数（非常短和简单）可能不需要一个名称，能够直接在一行代码或者或另一个函数中使用并用来快速完成任务。它们被称为**匿名函数**。]{style="color: black;"}

例如下面是一个匿名函数，它只用于保留数据集的字符变量。

```{r, eval=F}
linelist %>% 
  dplyr::slice_head(n=10) %>%  #等效于 base R 的“head”函数：返回数据集的前 n 个观察结果
  select(function(x) is.character(x)) 
```

```{r, echo=F}
linelist %>% 
  dplyr::slice_head(n=10) %>%  #等效于 base R 的“head”函数：返回数据集的前 n 个观察结果
  select(function(x) is.character(x)) %>%  
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```

然后是另一个函数，用于选择我们数据集的每一个观察值（当我们有每个患者有许多纵向数据记录时，例如按日期或访问顺序排序后，这种做法可能是有意义的）。 在这种情况下，在 dplyr 外部写入的函数应该是 `function (x) (x%%2 == 0)` 以用于包含所有行号的向量。

```{r, eval=F}
linelist %>%   
   slice_head(n=20) %>% 
   tibble::rownames_to_column() %>% # 添加每个obs的索引作为行名以清楚地看到最终选择
   filter(row_number() %%2 == 0)
```

```{r, echo=F}
linelist %>%   
   slice_head(n=20) %>% 
   tibble::rownames_to_column() %>%    #添加每个obs的索引作为行名以清楚地看到最终选择
   filter(row_number() %%2 == 0) %>% 
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )

```

基于 base R 用于相同任务的代码是：

```{r, eval = F}

linelist_firstobs <- head(linelist, 20)

linelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),]
```

```{r, echo=F}

linelist_firstobs <- head(linelist, 20)

linelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),] %>% 
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )

```

[**警示:** 尽管创建函数确实可以帮助我们精简或者优化代码。但是如果没有经过深思熟虑，没有恰当的编写函数导致返回错误，这种情况下编写函数或者修复函数是非常耗时的。基于这个原因，我们通常建议首先编写普通的R 代码并确保它能完成我们的意图。然后再将其转换为具有以上三个组件的函数。]{style="color: orange;"}

## 案例

### 返回几列数据的比例表 {.unnumbered}

尽管我们已经拥有来自不同 packages 的很多很好的函数，它们允许用户以非常简单和漂亮的方式总结信息。 但是我们仍然会尝试自己的方式，这是我们习惯编写函数的第一步。

在这个例子中，我们想展示如何编写一个简单的函数来避免多次复制粘贴相同的代码。

```{r}

proptab_multiple <- function(my_data, var_to_tab){
  
  #在制表之前打印每个感兴趣的变量的名称
  print(var_to_tab)

  with(my_data,
       rbind( # 按行绑定下面两个函数的结果
        #列出感兴趣的变量：只给出数字
          table(my_data[[var_to_tab]], useNA = "no"),
          #计算每个感兴趣变量的比例并将值四舍五入到小数点后两位
         round(prop.table(table(my_data[[var_to_tab]]))*100,2)
         )
       )
}


proptab_multiple(linelist, "gender")

proptab_multiple(linelist, "age_cat")

proptab_multiple(linelist, "outcome")


```

[**提示:** 如上所示，在您的函数中添加注释是非常重要的。请记住，函数的目的是使带飞更易于阅读，更短且更高效。所以人们应该能够通过它的名称来理解函数的作用，并且能够通过阅读注释来了解更多的计算细节。]{style="color: darkgreen;"}

第二种选择是在通过循环中使用此函数以重复执行该过程：

```{r}


for(var_to_tab in c("gender","age_cat",  "outcome")){
  
  print(proptab_multiple(linelist, var_to_tab))
  
}

```

一种更简单的方法是使用base R "apply"而不是"for loop"，如下所示：

```{r, include= FALSE, eval=FALSE}

base::lapply(linelist[,c("gender","age_cat", "outcome")], table)

```

[**提示:** R 通常被定义为一种函数编程语言。几乎在您运行任何一行代码的时候，您都在使用一些内置函数。如果您经常查看您日常使用的基本函数是如何构建的，对于编写自己的函数，这是非常好的一个习惯。查看基本函数的快捷方式是选择函数名称，然后单击 Ctrl + F2 或者 fn + F2 或 Cmd + F2 （取决于您的计算机）。]{style="color: darkgreen;"}

## 使用 purrr：编写可以迭代应用的函数

### 修改数据集中多个列的类 {.unnumbered}

假设原始`linelist` 数据中的许多字符变量需要更改为"因素"以进行分析和绘图。 我们可以使用 `lapply()` 在一行代码中完成所有相关变量的转换，而不是多次重复该步骤。

[**警示:**`lapply()` 会返回一个列表，因此使用它作为最后一步时可能需要一些格外的修改。]{style="color: orange;"}

```{r, include=FALSE}

linelist_factor1 <- linelist %>%
      lapply(
          function(x) if(is.character(x)) as.factor(x) else x) %>%
      as.data.frame() %>% 
      glimpse()

```

或者可以使用 **purrr** package 中的 `map_if()` 函数完成相同的步骤。

```{r}

linelist_factor2 <- linelist %>%
  purrr::map_if(is.character, as.factor)


linelist_factor2 %>%
        glimpse()

```

### 基于不同的变量迭代生成图形 {.unnumbered}

我们将在此处制作饼图，以查看 H7N9 爆发期间中国各省患者的分布情况。 我们将只用我们创建的函数，而不是为每个省重复一遍代码。

```{r}

# 使用 highchart
options(highcharter.theme =   highcharter::hc_theme_smpl(tooltip = list(valueDecimals = 2)))


#创建一个名为“chart_outcome_province”的函数，它将数据集和要绘制的省份名称作为参数。 

chart_outcome_province <- function(data_used, prov){
  
  tab_prov <- data_used %>% 
    filter(province == prov,
           !is.na(outcome))%>% 
    group_by(outcome) %>% 
    count() %>%
    adorn_totals(where = "row") %>% 
    adorn_percentages(denominator = "col", )%>%
    mutate(
        perc_outcome= round(n*100,2))
  
  
  tab_prov %>%
    filter(outcome != "Total") %>% 
  highcharter::hchart(
    "pie", hcaes(x = outcome, y = perc_outcome),
    name = paste0("Distibution of the outcome in:", prov)
    )
  
}

chart_outcome_province(flu_china, "Shanghai")
chart_outcome_province(flu_china,"Zhejiang")
chart_outcome_province(flu_china,"Jiangsu")


```

因素

### 基于不同的变量迭代生成表格 {.unnumbered}

在这里，我们将创建一个表格包括三个参数。我们希望为每个省份制作这张表格。 我们的参数是发病和住院之间的延迟、康复百分比和病例的中位年龄。

```{r}


indic_1 <- flu_china %>% 
  group_by(province) %>% 
  mutate(
    date_hosp= strptime(date_of_hospitalisation, format = "%m/%d/%Y"),
    date_ons= strptime(date_of_onset, format = "%m/%d/%Y"), 
    delay_onset_hosp= as.numeric(date_hosp - date_ons)/86400,
    mean_delay_onset_hosp = round(mean(delay_onset_hosp, na.rm=TRUE ), 0)) %>%
  select(province, mean_delay_onset_hosp)  %>% 
  distinct()
     

indic_2 <-  flu_china %>% 
            filter(!is.na(outcome)) %>% 
            group_by(province, outcome) %>% 
            count() %>%
            pivot_wider(names_from = outcome, values_from = n) %>% 
    adorn_totals(where = "col") %>% 
    mutate(
        perc_recovery= round((Recover/Total)*100,2))%>% 
  select(province, perc_recovery)
    
    
    
indic_3 <-  flu_china %>% 
            group_by(province) %>% 
            mutate(
                    median_age_cases = median(as.numeric(age), na.rm = TRUE)
            ) %>% 
  select(province, median_age_cases)  %>% 
  distinct()

#加入三个参数的数据集

table_indic_all <- indic_1 %>% 
  dplyr::left_join(indic_2, by = "province") %>% 
        left_join(indic_3, by = "province")


#在 flextable 中打印参数


print_indic_prov <-  function(table_used, prov){
  
  #首先转换一点数据框以方便打印
  indic_prov <- table_used %>%
    filter(province==prov) %>%
    pivot_longer(names_to = "Indicateurs", cols = 2:4) %>% 
   mutate( indic_label = factor(Indicateurs,
   levels= c("mean_delay_onset_hosp","perc_recovery","median_age_cases"),
   labels=c("Mean delay onset-hosp","Percentage of recovery", "Median age of the cases"))
   ) %>% 
    ungroup(province) %>% 
    select(indic_label, value)
  

    tab_print <- flextable(indic_prov)  %>%
    theme_vanilla() %>% 
    flextable::fontsize(part = "body", size = 10) 
    
    
     tab_print <- tab_print %>% 
                  autofit()   %>%
                  set_header_labels( 
                indic_label= "Indicateurs", value= "Estimation") %>%
    flextable::bg( bg = "darkblue", part = "header") %>%
    flextable::bold(part = "header") %>%
    flextable::color(color = "white", part = "header") %>% 
    add_header_lines(values = paste0("Indicateurs pour la province de: ", prov)) %>% 
bold(part = "header")
 
 tab_print <- set_formatter_type(tab_print,
   fmt_double = "%.2f",
   na_str = "-")

tab_print 
    
}




print_indic_prov(table_indic_all, "Shanghai")
print_indic_prov(table_indic_all, "Jiangsu")


```

## 运行良好的函数的提示和练习

函数式编程旨在简化代码并增加其可读性。 它不应该产生相反的结果。 下面的提示将帮助您拥有干净的代码和易于阅读的代码。

### 命名和语法 {.unnumbered}

-   避免使用环境中已经存在的其他函数可能已经使用的字符。

-   建议函数名简短易懂，方便其他读者理解

-   最好使用动词作为函数名称，使用名词作为参数名称。

### 列名和 *tidy* 的评估 {.unnumbered}

如果您想知道如何引用作为参数的列的名称，请阅读此 [tidyverse](https://dplyr.tidyverse.org/articles/programming.html) 编程指南。 其涵盖的主题包括 *tidy* 评估和使用双括号`{{ }}` 。

例如，这是上面提到的页面教程中的模板代码：

```{r, eval=F}

var_summary <- function(data, var) {
  data %>%
    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))
}
mtcars %>% 
  group_by(cyl) %>% 
  var_summary(mpg)

```

### 测试和错误处理 {.unnumbered}

函数的任务越复杂，出错的可能性就越大。 因此，有时需要在函数中添加一些验证方式，以帮助快速了解错误的来源并找到修复它的方法。

-   使用 `missing(argument)` 来检查一个参数的缺失性是被强烈推荐的。 这个检查可以简单的返回"TRUE"或"FALSE"值。

```{r , error=TRUE}

contain_covid19_missing <- function(barrier_gest, wear_mask, get_vaccine){
  
  if (missing(barrier_gest)) (print("please provide arg1"))
  if (missing(wear_mask)) print("please provide arg2")
  if (missing(get_vaccine)) print("please provide arg3")


  if (!barrier_gest == "yes" | wear_mask =="yes" | get_vaccine == "yes" ) 
       
       return ("you can do better")
  
  else("please make sure all are yes, this pandemic has to end!")
}


contain_covid19_missing(get_vaccine = "yes")

```

-   使用 `stop()` 检测更多错误。

```{r, error=TRUE}

contain_covid19_stop <- function(barrier_gest, wear_mask, get_vaccine){
  
  if(!is.character(barrier_gest)) (stop("arg1 should be a character, please enter the value with `yes`, `no` or `sometimes"))
  
  if (barrier_gest == "yes" & wear_mask =="yes" & get_vaccine == "yes" ) 
       
       return ("success")
  
  else("please make sure all are yes, this pandemic has to end!")
}


contain_covid19_stop(barrier_gest=1, wear_mask="yes", get_vaccine = "no")

```

-   正如我们在运行大多数内置函数时看到的那样，在某些情况下会弹出消息和警告。 我们可以通过使用函数 `message()` 和 `warning()`将这些集成到我们编写的函数中。

-   我们也可以使用 `safely()`来处理错误，它以一个函数作为参数并以安全的方式执行它。 事实上，如果遇到错误，该函数将不停止地执行。`safely()`返回一个包含两个对象的列表作为输出，它们是结果和它"跳过"的错误

我们可以通过首先将 `mean()` 作为函数运行，然后用 `safely()` 运行它来验证此函数。

```{r, warning=FALSE}

map(linelist, mean)
```

```{r, warning=FALSE}
safe_mean <- safely(mean)
linelist %>% 
  map(safe_mean)

```

如前所述，对我们的代码进行良好的注释是极好的方法。

<!-- ======================================================= -->

## 资源

[R for Data Science link](https://r4ds.had.co.nz/functions.html)

[Cheatsheet advance R programming](https://www.rstudio.com/wp-content/uploads/2016/02/advancedR.pdf)

[Cheatsheet purr Package](https://purrr.tidyverse.org/)

[Video-ACM talk by Hadley Wickham: The joy of functional programming (how does map_dbl work)](https://youtube.videoken.com/embed/bzUmK0Y07ck)

# R 基础

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "basics_header_close.png"))
```

热烈欢迎！

本章节主要包括 R 的基本知识。本页面不是一个全面的教程，但提供了基础的要点，可以帮助你巩固记忆。[学习资源](#learning) 部分链接到更全面的教程。

此页面的部分内容已在 [R4Epis](https://r4epis.netlify.app/) 项目的许可下进行了改编。

有关从STATA、SAS或Excel转换到R的提示，请参阅 [转换到 R] 页面。

```{r, echo=F}
# 导入整理过的埃博拉病毒线列表
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
pacman::p_load(apyramid)
```

<!-- ======================================================= -->

## 为什么用 R **？**

如 [R project 网站](https://www.r-project.org/about.html) 所述，R 是一种用于统计计算和图形的编程语言和环境。 它具有高度通用性、可扩展性和社区驱动性。

**费用**

R是免费的！ 其基于免费和开源社区中强烈的道德规范。

**重复性**

与 Excel 或其他主要通过点击或手动交互的工具相比，通过编程语言进行数据管理和分析可提高**可重复性**，使**错误检测**更容易，并减轻您的工作量。

**社区**

R 社区拥有巨量的和互相协助的用户。每天都有解决当前问题的新 packages 和工具被开发出来，并由用户社区进行审查。例如，[R-Ladies](https://rladies.org/) 是一个全球性组织，其使命是促进 R 社区的性别多样性，是最大的 R 用户组织之一。 可能在您附近就有一个分会！

## 关键术语

**RStudio** - RStudio 是一个图形用户界面 (GUI)用于更方便的使用 **R**。详细信息请参考[RStudio](#rstudio) 。

**对象** - 您在 R 中存储的所有内容------数据集、变量、村庄名称列表、总人口数，甚至诸如图表之类的输出------都是分配了名称的**对象**，并且可以在之后的代码中引用。详细信息请参考 [Objects](#objects) 。

**函数** - 函数是一个接受输入并返回转换后的输出的操作。详细信息请参考 [Functions](#functions) 。

**Packages** - R package 是一组可共享的函数。详细信息请参考 [Packages](#packages) 。

**脚本** - 脚本是保存您的代码的文档文件。详细信息请参考 [Scripts](#scripts) 。

## 学习资源 {#learning}

### RStudio 资源 {.unnumbered}

**帮助文档**

在 RStudio 的"帮助"选项中可以搜索有关 R packages 和特定函数的帮助文档。 它还位于包含文件、绘图和packages 的面板中（通常在右下面板）。 还有一种快捷方式，您可以在 R 控制台中写入问号与packages 或函数的名称来打开相关的帮助页面。 请不要包括括号。

例如： `?filter` 或者 `?diagrammeR` 。

**交互指南**

在 RStudio 中有多种交互式学习 R 的方法。

RStudio 本身提供了一个由 [**learnr**](https://blog.rstudio.com/2020/02/25/rstudio-1-3-integrated-tutorials/) R package 提供支持的教程面板。 只需安装此 package 并通过右上方 RStudio 面板（其中还包含环境和历史选项卡）中的新"教程"选项打开教程。

R package [**swirl**](https://swirlstats.com/) 在 R 控制台中提供交互式课程。 安装并加载此 package ，然后在 R 控制台中运行命令 `swirl()`（空括号）。 您将看到控制台中出现提示。 通过在控制台中写入代码来响应。 它将指导您完成您选择的课程。

### 速查表 {.unnumbered}

[RStudio](https://rstudio.com/resources/cheatsheets/) 网站上有许多 PDF"速查表"，例如：

-   **forcats** package 的因子\
-   **lubridate** package 的日期与时间\
-   **stringr** package 的字符串\
-   **purrr** package 的迭代运算\
-   数据导入\
-   **dplyr** package 的数据转换速查表\
-   R Markdown(用于创建PDF、Word、Powerpoint等文档...)\
-   Shiny (用于构建交互式 web 应用程序)\
-   **ggplot2** package 的数据可视化\
-   地理信息系统制图 (GIS)\
-   **leaflet** package (交互式地图)\
-   Python 与 R (**reticulate** package)

这是一个专门针对 [Excel 用户](https://jules32.github.io/r-for-excel-users/) 的在线 R 资源。

### Twitter {.unnumbered}

R 有一个充满活力的 twitter 社区，您可以在那里学习并了解技巧、快捷功能和最新消息 - 请关注以下帐户：

-   关注我们！ [\@epiRhandbook](https://twitter.com/epirhandbook)\
-   R Function A Day [\@rfuntionaday](https://twitter.com/rfunctionaday) 是一个**不可思议的**资源\
-   R for Data Science [\@rstats4ds](https://twitter.com/rstats4ds?lang=en)\
-   RStudio [\@RStudio](https://twitter.com/rstudio?lang=en)\
-   RStudio Tips [\@rstudiotips](https://twitter.com/rstudiotips)\
-   R-Bloggers [\@Rbloggers](https://twitter.com/Rbloggers)\
-   R-ladies [\@RLadiesGlobal](https://twitter.com/RLadiesGlobal)\
-   Hadley Wickham [\@hadleywickham](https://twitter.com/hadleywickham?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor)

此外:

**\#epitwitter** 和 **\#rstats**

### 免费在线资源 {.unnumbered}

Garrett Grolemund 和 Hadley Wickham 合著的 [R for Data Science](https://r4ds.had.co.nz/) 是具有权威性的一本书。

[R4Epis](https://r4epis.netlify.app/) 项目网站旨在"开发标准化的数据整理、分析和报告工具，以涵盖将在 MSF 应急响应环境中进行的常见爆发类型和基于人口的调查。" 您可以找到 R 基础培训材料、关于爆发和调查的 RMarkdown 报告模板以及能帮助您设置的教程。

### 其他语言 {.unnumbered}

[Materiales de RStudio en Español](https://www.rstudio.com/collections/espanol/)

[Introduction à R et au tidyverse (Francais)](https://juba.github.io/tidyverse/index.html)

<!-- ======================================================= -->

## 安装

### R 和 RStudio {.unnumbered}

**如何安装 R**

访问此网站 <https://www.r-project.org/> 并下载最新版本并且适合您计算机的 R 。

**如何安装 RStudio**

访问此网站[\<https://rstudio.com/products/rstudio/download/\>](https://rstudio.com/products/rstudio/download/){.uri} 并下载最新版本并且适合您计算机的 RStudio。

**权限**\
请注意，您应该将 R 和 RStudio 安装到具有读写权限的驱动器上。 否则，您在安装 R packages （经常发生）时将受到影响。 如果遇到问题，请尝试通过右键单击 RStudio 图标并选择"以管理员身份运行"来打开 RStudio。 其他提示可以在 [网络驱动器上的 R] 页面中找到。

**如何升级 R 和 RStudio**

您的 R 版本会在启动时在 R 控制台显示。 您还可以运行 `sessionInfo()`来查看。

要更新 R，请访问上述网站并重新安装 R。或者您可以通过运行 `installr::updateR()` 来使用 **installr** package（在 Windows 上）。 这将打开对话框来帮助您下​​载最新的 R 版本并将更新。 详细信息请参考 **installr** [文档](https://www.r-project.org/nosvn/pandoc/installr.html)。

请注意，旧的 R 版本仍将存在于您的计算机中。 您可以通过单击 RStudio 中的"工具"-\>"全局选项"并选择 R 版本来临时运行 R 的旧版本（旧"安装"）。 如果您想使用尚未更新的 package 在最新版本的 R 上工作，这会很有用。

要更新 RStudio，您可以访问上面的网站并重新下载 RStudio。 另一种选择是在 RStudio 中单击"帮助"-\>"检查更新"，但这可能不会显示最新的更新。

要查看本指南制作时使用了哪些版本的 R、RStudio 或packages，请参阅页面 [编辑样式和技术规范]。

### 其他可能需要安装的软件

-   TinyTeX (将 RMarkdown 文档编译为 PDF)
-   Pandoc (编译 RMarkdown 文档)
-   RTools (创建 R *packages*)
-   phantomjs (保存动态网络的静止图像，例如传播链)

#### TinyTex {.unnumbered}

TinyTex 是一个自定义的 LaTeX 编译器，在尝试从 R 生成 PDF 时很有用。

详细信息请参考 [\<https://yihui.org/tinytex/\>](https://yihui.org/tinytex/){.uri} 。

从 R 安装 TinyTex：

```{r, eval=F}
install.packages('tinytex')
tinytex::install_tinytex()
# 要卸载 TinyTeX，请运行 tinytex::uninstall_tinytex()
```

#### Pandoc {.unnumbered}

Pandoc 是一个文档转换器，一个独立于 R 的软件。**它与 RStudio 捆绑在一起，不需要下载。**它能帮助将 Rmarkdown 文档转换为 .pdf 等格式并添加复杂功能。

#### RTools {.unnumbered}

RTools 是为 R 构建 packages 的软件的集合

从此网站安装： [\<https://cran.r-project.org/bin/windows/Rtools/\>](https://cran.r-project.org/bin/windows/Rtools/){.uri}

#### phantomjs {.unnumbered}

phantomjs 通常用于抓取网页的"截图"。例如，当您使用 **epicontacts** package 创建传播链时，将生成一个交互式和动态的HTML文件。如果您想要一个静态图像，可以使用 [**webshot**](https://wch.github.io/webshot/articles/intro.html) package 来自动化这个过程。这将需要外部程序 "phantomjs" 。你可以使用命令 `webshot::install_phantomjs()`通过 webshot package 安装 phantomjs。

<!-- ======================================================= -->

## RStudio {#rstudio}

### RStudio 导览 {.unnumbered}

**首先,打开 RStudio**。因为它们的图标看起来非常相似，所以要确保您打开的是 RStudio 而不是 R 。

要使 RStudio 工作，您还必须在计算机上安装 R（有关安装说明，请参见上文）。

RStudio 是一个更方便使用 R 的界面 (GUI)。您可以将 R 视为车辆的引擎，执行关键工作，而 RStudio 则为车辆的主体（带有座椅、配件等）。您实际上是在使用引擎来前进！ 您可以在[此处](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf)查看完整的 RStudio 用户界面速查表 (PDF)。

默认情况下，RStudio 显示四个矩形面板。

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "RStudio_overview.png"))
```

[**注释*:*** 如果您的 RStudio 只显示一个左侧面板，这是因为您还没打开脚本。]{style="color: black;"}

**源代码面板**\
默认情况下，此面板位于左上角，是用于编辑、运行和保存[脚本](#scripts)的面板。 脚本包含您要运行的代码。 此面板还可以显示数据集（数据框）以供查看。

对于 Stata 用户，此面板类似于您的 Do-file 和 Data Editor 窗口。

**R 控制台面板**

R 控制台（默认情况下位于 R Studio 的左侧或左下窗格）是 R"引擎"的所在地。 这是代码实际运行的地方，非图形输出和错误或警告消息出现的地方。 您可以直接在 R 控制台中输入和运行代码，但要意识到这些代码不会像从脚本运行代码时那样保存。

如果您熟悉 Stata，R 控制台就像命令窗口和结果窗口。

**环境面板**\
此窗格默认位于右上角，常用于查看当前会话中 R 环境中[对象](#objects)的概要。 这些对象可能包括导入、修改或创建的数据集、您定义的参数（例如分析的特定 Epi 周）或您在分析期间定义的向量或列表（例如区域名称）。 您可以单击数据框名称旁边的箭头以查看其变量。

在 Stata 中，此面板与变量管理器窗口最相似。

此窗格还包含历史记录，您可以在其中查看以前的代码。 它还有一个"教程"选项卡，如果您安装了**learnr** package，您可以在其中完成交互式 R 教程。 它还有一个用于外部连接的"连接"窗格，如果您选择与 Github 交互，则可以有一个"Git"面板。

**绘图、查看器、Packages 和帮助面板**

右下窗格包括几个重要的选项卡。 包括地图在内的绘图图形将显示在绘图面板中。 交互式或 HTML 输出将显示在查看器面板中。 帮助面板可以显示文档和帮助文件。 文件窗格是一个浏览器，可用于打开或删除文件。 "Packages "窗格允许您查看、安装、更新、删除、加载/卸载 R Packages ，并查看您拥有的包的版本。 要了解有关 Packages 的更多信息，请参阅下面的 [packages](#packages) 部分。

此面板等效与 Stata的绘图管理器和项目管理器窗口。

### RStudio 设置 {.unnumbered}

通过在工具下拉菜单中选择全局选项。 您可以更改默认设置，包括外观/背景颜色。

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "RStudio_tools_options_1.png"))

knitr::include_graphics(here::here("images", "RStudio_tools_options.png"))
```

**重启**

如果您的 R 卡住了，您可以通过转到"会话"菜单并单击"重新启动 R"来重新启动 R。 这避免了关闭和打开 RStudio 的麻烦操作。 执行此操作时，R 环境中的所有内容都将被删除。

### 键盘快捷键 {.unnumbered}

下面是一些非常有用的键盘快捷键。 如要查看适用于 Windows、Max 和 Linux 的所有键盘快捷键，请参阅 RStudio [用户界面速查表](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf)的第二页。

| Windows/Linux                    | Mac                    | Action 操作                                                                       |
|----------------------------------|------------------------|-----------------------------------------------------------------------------------|
| Esc                              | Esc                    | 中断当前命令 (如果您不小心运行了不完整的命令并且无法在 R 控制台中看到"+"时很有用) |
| Ctrl+s                           | Cmd+s                  | 保存(脚本)                                                                        |
| Tab                              | Tab                    | 自动补全                                                                          |
| Ctrl + Enter                     | Cmd + Enter            | 运行当前行/选择的代码                                                             |
| Ctrl + Shift + C                 | Cmd + Shift + c        | 注释/取消注释突出显示的行                                                         |
| Alt + -                          | Option + -             | 插入`<-`                                                                          |
| Ctrl + Shift + m                 | Cmd + Shift + m        | 插入`%>%`                                                                         |
| Ctrl + l                         | Cmd + l                | 清空 R 控制台                                                                     |
| Ctrl + Alt + b                   | Cmd + Option + b       | 运行，从开始行到当前行                                                            |
| Ctrl + Alt + t                   | Cmd + Option + t       | 运行当前部分的代码 (R Markdown)                                                   |
| Ctrl + Alt + i                   | Cmd + Shift + r        | 插入代码块 (into R Markdown)                                                      |
| Ctrl + Alt + c                   | Cmd + Option + c       | 运行当前代码块 (R Markdown)                                                       |
| up/down arrows in R console      | 相同                   | 切换最近运行的命令                                                                |
| Shift + up/down arrows in script | 相同                   | 选择多个代码行                                                                    |
| Ctrl + f                         | Cmd + f                | 在当前脚本中查找和替换                                                            |
| Ctrl + Shift + f                 | Cmd + Shift + f        | 在文件中查找（在多个脚本中搜索/替换）                                             |
| Alt + l                          | Cmd + Option + l       | 折叠选中的代码                                                                    |
| Shift + Alt + l                  | Cmd + Shift + Option+l | 展开选定的代码                                                                    |

[**提示*:*** 请用 Tab 按键打开 RStudio 的自动补全功能。此功能可阻止拼写错误。编写代码时按 Tab 会根据您目前编写的代码显示可能的函数或者对象的下拉菜单。]{style="color: darkgreen;"}

<!-- ======================================================= -->

## 函数 {#functions}

函数是使用 R 的核心要素。函数是您执行任务和操作的方式。 许多函数随 R 一起安装，更多函数可以在packages 中下载（在[packages](#packages) 部分详细解释）。您甚至可以编写自定义函数。

此部分关于函数的基础，解释了：

-   什么是函数以及它们如何工作\
-   什么是函数**参数**\
-   如何在帮助文档下理解函数

关于语法的快速说明：在本指南中，函数是用带括号的代码文本编写的，例如：`filter()`。 如 [packages](#packages)部分所述，函数在 *packages* 内下载。 在本手册中，package 名称以**粗体**显示，例如 **dplyr**。 有时在示例代码中，您可能会看到函数名称显式链接到其包名称，并带有两个冒号 (`::`)，如下所示：`dplyr::filter()`。 此链接的目的会在 packages 部分中解释。

<!-- ======================================================= -->

### 简单函数 {.unnumbered}

**函数就像一台机器，它接收输入，对这些输入做一些处理，然后产生输出。**输出是什么取决于函数。

**函数通常对放置在函数括号内的某个对象进行操作。** 例如，函数 `sqrt()` 计算一个数的平方根：

```{r basics_function_sqrt}
sqrt(49)
```

提供给函数的对象也可以是数据集中的一列（有关所有类型的对象的详细信息，请参阅[对象](#objects)部分）。 由于 R 可以存储多个数据集，因此您需要同时指定数据集和列。 一种方法是使用 `$` 符号来链接数据集的名称和列的名称 (`dataset$column`)。 在下面的示例中，函数 `summary()` 被应用于数据集 `linelist` 中的数字列 `age`，并且输出是该列的数字值和缺失值的摘要。

```{r basics_functions_summary}
# 打印数据集“linelist”中列“age”的汇总统计信息
summary(linelist$age)
```

[**注释*:*** 一个函数其实代表了复杂的附加代码，这些代码已经被打包成一个简单的命令。]{style="color: black;"}

<!-- ======================================================= -->

### 多参数函数 {.unnumbered}

函数通常要求多个输入，即**参数**，位于函数的括号内。参数通常用逗号分隔。

-   有些参数是函数正常运行所必需的，其他参数是可选的\
-   可选参数具有默认设置\
-   参数可以是用字符、数字、逻辑 (TRUE/FALSE) 和其他输入

下面是一个有趣的虚构函数示例: `oven_bake()`。 它接受一个输入参数（例如一个数据集，或在本例中为 "面团"）并按照附加参数（`minutes =` 和`temperature =`）的指定对其执行操作。 输出可以打印到控制台，或使用赋值运算符 `<-`保存。

```{r basics_functions_image, echo=F, out.width = "75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Function_Bread_Example.png"))
```

**在更现实的示例中**，`age_pyramid()` 可以生成基于定义的年龄组和二元拆分列（例如`gender`）的年龄金字塔图。 该函数在括号内需要三个参数，用逗号分隔。 提供给参数的值中， `linelist` 作为要使用的数据， `age_cat5` 作为要计数的列，`gender`作为用于按颜色拆分的金字塔的二进制列。

```{r basics_functions_arguments, include=FALSE, results='hide', message=FALSE, warning=FALSE,}
## 通过指定分类间隔来创建年龄组变量
linelist$age_group <- cut(linelist$age, breaks = c(0, 5, 10, 15, 20, 30, 45, 60))
```

```{r message=FALSE, warning=FALSE,  out.width = "75%", out.height="75%"}
# 创建年龄金字塔
age_pyramid(data = linelist, age_group = "age_cat5", split_by = "gender")
```

上面的命令可以等效地写成如下代码：更长的格式，每个参数一行。 这种风格更容易阅读，更容易用 `#` 写"注释"来注释每个部分（广泛注释是一种很好的做法！）。 要运行这个更长的命令，您可以突出显示整个命令并单击"运行"，或者将光标放在第一行，然后同时按下 Ctrl 和 Enter 键。

```{r message=FALSE, warning=FALSE,  out.width = "75%", out.height="75%"}
# 创建年龄金字塔
age_pyramid(
  data = linelist,        # 用案例 linelist
  age_group = "age_cat5", # 提供年龄组栏
  split_by = "gender"     # 用性别列来划分金字塔
  )
```

如果参数以特定顺序（函数文档中指定）编写，则不需要指定参数赋值的前半部分（例如 `data =`）。 下面的代码生成与上面完全相同的金字塔，因为该函数规定的参数顺序：数据框、`age_group` 变量、`split_by` 变量。

```{r, basics_functions_pyramid2, eval = FALSE, warning=FALSE, message=FALSE, , out.width = "75%", out.height="75%", eval=F}
# 此命令将产生与上面完全相同的图形
age_pyramid(linelist, "age_cat5", "gender")
```

**更复杂的 `age_pyramid()` 命令可能包含以下可选参数**：

-   显示比例而不是数量（设置`proportional = TRUE`，默认为`FALSE`）\
-   指定要使用的两种颜色（`pal =` 是"palette"的缩写，并提供了一个包含两个颜色名称的向量。有关函数 `c()` 如何生成向量的信息，请参见[对象](#objectstructure)页面）

[**注释:** 对于使用参数指定方式的输入参数（例如,`proportional = TRUE`),它们在所有参数中的顺序是无关紧要的。]{style="color: black;"}

```{r message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"}
age_pyramid(
  linelist,                    # 用案例 linelist
  "age_cat5",                  # 提供年龄组栏
  "gender",                    # 用性别列来划分金字塔
  proportional = TRUE,         # 显示比例而不是数量
  pal = c("orange", "purple")  # 指定颜色
  )
```

<!-- ======================================================= -->

### 编写函数 {#编写函数 .unnumbered}

R 是一种面向函数的语言，因此您有能力编写自己的函数。 创建函数有几个优点：

-   促进模块化编程 - 代码会被分成独立且可被管理的模块\
-   不用重复地复制和粘贴，这很容易出错\
-   给代码段起一个容易记住的名字

如何编写函数在 [编写函数](#编写函数)页面中有深入的介绍。

<!-- A function is given a name and defined with the assignment operator `<-` to a special **base** R function called `function()`. Within the parentheses, the arguments that the function will accept are defined. This is followed by curly brackets `{ }`, within which the actual code of the function is written.     -->

```{r, eval=F, echo=F}
my_function <- function( ARGUMENTS HERE ){ CODE HERE }
```

<!-- The arguments should be provided in the syntax `argument = default`, separated by commas.   -->

<!-- Here is an example where we create a function `staff_calc()` to serve as a staffing calculator for COVID-19 case investigation and contact tracing calls.   -->

<!-- The arguments (inputs) and their default values will be:   -->

<!-- * `daily_cases = NULL` The number of new COVID-19 cases per day   -->

<!-- * `contacts_each = 5` The number contacts enumerated for each case   -->

<!-- * `time_case = 0.5`  Number of hours to complete a case investigaton by phone   -->

<!-- * `time_contact = 0.25`  Number of hours to complete a contact follow-up by phone   -->

<!-- * `time_day = 8` The number of hours one staff works per day   -->

<!-- Below, the function is created. The code ends with the special function `return()`, which is what the function produces.    -->

<!-- ```{r message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"} -->

<!-- staff_calc <- function(daily_cases = NULL, contacts_each = 5, -->

<!--                        time_case = 0.5, time_contact = 0.25, time_day = 8){ -->

<!--   # Define total daily hours for calling cases -->

<!--   case_hours <- daily_cases * time_case  -->

<!--   # Define total daily hours for calling contacts -->

<!--   contact_hours <- daily_cases * contacts_each * time_contact -->

<!--   # Calculate number of staff required -->

<!--   staff_required <- (case_hours + contact_hours)/time_day -->

<!--   return(staff_required) -->

<!-- } -->

<!-- ``` -->

<!-- Once this code is run, the function will be defined and will appear in the R Environment. We can run the function. Below all the default values are used and the `daily_cases = ` is set to 150.   -->

```{r eval=F, echo=F, message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"}
staff_calc(daily_cases = 150)
```

```{r, eval=F, echo=F}
case_incidence <- tibble(
  dates = seq.Date(from = as.Date("2020-05-01"), to = as.Date("2020-05-21"), by = 1),
  projected_incidence = c(102,110,50,37,106,190,146,138,135,111,60,43,189,184,185,80,44,97,254,291,288),
  staff_needed = staff_calc(projected_incidence)
)

ggplot(case_incidence, aes(x = dates))+
  geom_line(aes(y = projected_incidence))+
  geom_line(aes(y = staff_needed))
```

<!-- There are many other nuances to understand when writing functions, as discussed in the page [Writing functions].   -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Packages {#packages}

**Packages 中包含函数**

R package 是包含预定义函数的可共享代码和文档包。 R 社区的用户一直在开发针对特定问题的 package ，这些 package 很可能会对您的工作有所帮助！ 在使用 R 时，您将安装和使用数百个 packages。

在安装时，R 包含用于执行常见基本任务的 "**base**" packages 和函数。 但是许多 R 用户创建了专门的函数。这些函数经过 R 社区的验证后，您可以将其作为 **packages** 下载供自己使用。 在本指南中，packages 名称以**粗体**显示。在使用 R 时，具挑战性的方面之一是：有许多函数或 packages 可供选择来完成特定的任务。

### 安装和加载 {.unnumbered}

从网上下载并且安装到您的计算机的 **packages** 中包含函数。 下载包后，它会存储在您的"库"中。 然后，您可以在当前 R 会话中通过"加载" package 来访问它包含的函数。.

R 可以被视为您的个人图书馆：当您下载一个包时，您的图书馆会获得一本新的函数书。但是每次您想使用该书中的函数时，您都必须从图书馆借用（"加载"）该函数书。

总之，要使用 R package 中包含的函数，必须完成2 个步骤：

1)  package 必须被**安装** (一次)\
2)  package 必须被**加载** (每个 R 会话)

#### 库 {.unnumbered}

您的"库"实际上是您计算机上的一个文件夹，其中包含每个已安装的 package 的文件夹。 要找到库的位置，先找出 R 在您的计算机中的安装位置，并查找名为"win-library"的文件夹。 例如：`R\win-library\4.0`（4.0 是 R 版本 - 您下载的 R 的每个版本都有不同的库）。

您可以通过输入 `.libPaths()`（括号内为空）来打印库的文件路径。 如果使用 [网络驱动器上的 R]，这将变得尤为重要。

#### 从 CRAN 安装 {.unnumbered}

通常，R 用户从 CRAN 下载 packages 。 CRAN (Comprehensive R Archive Network) 是 R 社区成员发布的关于 R packages 的在线公共仓库。

从 CRAN 下载 packages 时，您是否担心病毒和安全性？ 阅读有关该主题的[文章](https://support.rstudio.com/hc/en-us/articles/360042593974-R-and-R-Package-Security) 。

#### 如何安装和加载 {.unnumbered}

在本指南中，我们建议使用 **pacman** package（"package manager"的缩写）。 它提供了一个方便的函数 `p_load()`。此函数会在必要时安装一个包并加载它以在当前 R 会话中使用。

其语法相当简单。 只需在`p_load()`括号内列出包的名称，用逗号分隔。 下述命令将安装 **rio**、**tidyverse** 和 **here** packages （如果尚未被安装），并将加载它们以供使用。 如果您与他人共享脚本，`p_load()` 方法即方便又简洁。 请注意，packages 名称区分大小写。

```{r}
# 安装（如有必要）并加载软件包以供使用
pacman::p_load(rio, tidyverse, here)
```

请注意，我们使用了 `pacman::p_load()`语法，它在函数名称 (`p_load()`) 之前增加了packages 名称 (**pacman**)，并由两个冒号 :: 连接。 这个语法很有用，因为它还加载了 **pacman** 包（假设它已经安装）。

**base** R 中的替代函数也会被经常使用。 用于安装 package 的 **base** R 函数是 `install.packages()`。 要安装的package 的名称必须在括号中加上引号。 如果希望用一个命令安装多个 packages，它们必须列在字符向量 `c()`中。

[**注释:** 此命令会安装 packages 但不会加载 packages 在当前会话中使用。]{style="color: black;"}

```{r, eval=F}
# 使用 base R 安装单个 package
install.packages("tidyverse")

# 使用 base R 安装多个 packages
install.packages(c("tidyverse", "rio", "here"))
```

安装也可以通过点击进入RStudio"Packages"面板，点击"Install"并搜索所需的 package 名称来完成。

加载 package 以供使用（安装后）的 **base** R 函数是 `library()`。 它一次只能加载一个 package（使用 `p_load()`的另一个原因）。 package 名称可以带引号或不带引号。

```{r, eval=F}
# 使用 base R 加载 package
library(tidyverse)
library(rio)
library(here)
```

要检查 package 是否已被安装和/或已加载，您可以在 RStudio 中查看 package 面板。 如果安装了该package，则会在此面板处显示版本号。 如果package的框被选中，则当前会话已经加载它。

**从 Github 安装**

有时，您需要安装 CRAN 尚未提供的 package 。 或者该package 可能在 CRAN 上可用，但您想要具有新功能的**开发者**版本。 这些通常托管在 [github.com](https://github.com/) 网站上的一个免费的、面向公众的"资源库"中。 在 [版本控制和与 Git 和 Github 的协作] 的手册页面中阅读有关 Github 的更多信息。

要从 Github 下载 R packages ，您可以使用 **pacman** 的 `p_load_gh()` 函数。它会在必要时安装 package，并加载它以在您当前的 R 会话中使用。 安装的替代方法包括使用 **remotes** 或 **devtools** package。 在[package 文档](https://cran.r-project.org/web/packages/pacman/pacman.pdf)中阅读有关 **pacman** 中所有函数的详细信息。

要从 Github 安装，您必须提供更多信息。 您必须提供：

1)  资源库所有者的 Github ID
2)  包含package 的资源库的名称
3)  *(可选)* 您要下载的"分支"（特定开发版本）的名称

在下面的示例中，引号中的第一个单词是资源库所有者的 Github ID，斜杠后面是资源库的名称（package的名称）。

```{r, eval=F}
# 从 Github 存储库安装/加载 epicontacts package
p_load_gh("reconhub/epicontacts")
```

如果要从主分支以外的"分支"（版本）安装，请在资源库名称之后，添加"\@"之后再加分支名称。

```{r, eval=F}
# 从 Github 安装来自"timeline"分支的 epicontacts package
p_load_gh("reconhub/epicontacts@timeline")
```

如果 Github 的 package 版本与您电脑上的版本没有差异，则不会执行任何操作。 您可以通过使用 `p_load_current_gh()`和参数 `update = TRUE` 来"强制"重新安装。 [在此](http://trinker.github.io/pacman/vignettes/Introduction_to_pacman.html)阅读有关 **pacman** 的更多信息。

**从 ZIP 或 TAR 安装**

您可以从 URL 安装 package ：

```{r, eval=F}
packageurl <- "https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
```

或者将其以压缩文件的形式下载到您的计算机：

选项 1：使用 **remotes** package 中的 `install_local()`

```{r, eval=F}
remotes::install_local("~/Downloads/dplyr-master.zip")
```

选项 2：使用 **base** R 中的 `install.packages()`，提供 ZIP 文件的文件路径并设置 `type = "source` 和 `repos = NULL`。

```{r, eval=F}
install.packages("~/Downloads/dplyr-master.zip", repos=NULL, type="source")
```

### 代码语法 {.unnumbered}

为了在本指南中表述清楚，有时会使用 :: 符号在函数前面加上 package 名，如下所示： `package_name::function_name()`。

如果会话已经加载了package ，就不需要这种样式。 可以只使用`function_name()`。 然而，当函数名很常见并且可能存在于多个package 中时（例如`plot()`），增加package 名很有用。 如果package 尚未加载，则写入package 名称也会加载该package 。

```{r eval=FALSE}
# 此命令使用package “rio”及其函数“import()”来导入数据集
linelist <- rio::import("linelist.xlsx", which = "Sheet1")
```

### 函数的帮助文档 {.unnumbered}

要了解有关函数的更多信息，您可以在右下角 RStudio 的"帮助"选项卡中搜索它。 您还可以运行类似`?thefunctionname`的命令（将函数名称放在问号之后），帮助页面将出现在帮助面板中。 最后，还可以尝试在线搜索。

### 升级 packages {.unnumbered}

您可以通过重新安装来更新 packages。 您还可以单击 RStudio package 面板中的绿色"更新"按钮来查看哪些 packages有新版本。 请注意，如果函数的工作方式进行了重大修改，您的旧代码可能需要更新！

### 删除 packages {.unnumbered}

使用 **pacman** 中的 `p_delete()` 或 **base** R 中的 `remove.packages()`。或者，您可以找到包含您的packages 的文件夹并手动删除该文件夹。

### 从属性 {.unnumbered}

packages 通常依赖于其他 packages 才能工作。 这被称为从属性。 如果被依赖的 packages 无法安装，那么依赖它的 packages 也可能无法安装。

使用 `p_depends()` 查看 package 依赖哪些 packages ，使用 `p_depends_reverse()`查看哪些 packages 依赖它。

### 屏蔽函数 {.unnumbered}

两个或多个 packages 包含相同的函数名的情况并不少见。 例如，package **dplyr** 有一个 `filter()`函数，但 package **stats** 也有。 默认的`filter()`函数来源取决于这些 packages 在 R 会话中第一次加载的顺序------后者将是命令 `filter()`的默认来源。

您可以在 R Studio 的环境面板中检查顺序 - 单击"全局环境"下拉列表并查看 packages 的顺序。 该下拉列表中较低的 package 中的函数将屏蔽在下拉列表中较高的 package 中的同名函数。 首次加载 package 时，如果发生屏蔽，R 会在控制台中警告您，但这很容易被忽略。

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "masking_functions.png"))
```

以下是修复屏蔽的方法：

1)  在命令中指定 package 名称。 例如，使用 `dplyr::filter()`
2)  重新安排 packages 的加载顺序（例如在`p_load()`) 内），并**开始一个新的 R 会话**

### 分离/卸载 {.unnumbered}

要分离（卸载）package，请使用下述命令，使用正确的package名称和一个冒号。 请注意，这可能无法解决屏蔽问题。

```{r, eval=F}
detach(package:PACKAGE_NAME_HERE, unload=TRUE)
```

### 安装旧版本 {.unnumbered}

请参阅本[指南](https://support.rstudio.com/hc/en-us/articles/219949047-Installing-older-versions-of-packages)以安装特定 package 的旧版本。

### 推荐的packages {.unnumbered}

有关我们为日常流行病学推荐的 packages 列表，请参阅 [推荐的 packages ] 页面。

<!-- ======================================================= -->

## 脚本 {#scripts}

脚本是编程的基本组成部分。 它们是保存您的命令的文档（例如创建和修改数据集的函数、可视化等）。 您可以保存脚本并稍后再次运行。 从脚本中存储和运行命令有很多优点（与在 R 控制台"命令行"中输入命令相比）：

-   可移植性 - 您可以通过向他人发送您的脚本来与他们分享您的工作\
-   再现性 - 您和其他人能确切地知道您做了什么\
-   版本控制 - 您可以跟踪自己或同事所做的更改\
-   评论/注释 - 向您的同事解释您做了什么

### 注解 {.unnumbered}

在脚本中，您可以在 R 代码周围注释。 注释有助于向您自己和其他读者解释您在做什么。 您可以通过键入井号 (\#) 并在其后写下您的注释来添加注释。 注释文本将以与 R 代码不同的颜色显示。

在 \# 之后编写的任何代码都不会运行。 因此，如果不想删除某行代码，则在代码前放置 \# 也是一种临时阻止代码行（"注释掉"）的有用方法。 您可以通过突出显示它们并按 Ctrl+Shift+c（在 Mac 中为 Cmd+Shift+c）来一次注释掉/回多行。

```{r, eval = F}
# 注释可以单独在一行上
# 导入数据
linelist <- import("linelist_raw.xlsx") %>%   # 注释也可以在代码之后
# filter(age > 50)                          # 注释还可用于停用/阻止一行代码
  count()

```

-   注释您在做什么以及您**为什么**这样做\
-   将您的代码基于逻辑来分解\
-   为您的代码附上您正在执行的操作的每步的文本说明（例如编号的步骤）

### 格式 {.unnumbered}

您的编码格式很重要 - 特别是在团队中工作时。 我们提倡 **tidyverse** [格式指南](https://style.tidyverse.org/)。 还有诸如 **styler** 和 **lintr** 之类的packages 可以帮助您符合这种格式。

使您的代码对其他人可读的一些要点：\
\*命名对象时，仅使用小写字母、数字和下划线 `_`，例如 `my_data`\
\* 频繁地使用空格，包括运算符周围，例如 `n = 1` 和`age_new <- age_old + 3`

### 示例脚本 {.unnumbered}

下面是一个简短的 R 脚本示例。 请记住，您在注释中越简洁地解释您的代码，您的同事就会越喜欢您的代码！

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "example_script.png"))
```

<!-- ======================================================= -->

### R markdown {.unnumbered}

R markdown 脚本是一种 R 脚本，其中脚本本身成为输出文档（PDF、Word、HTML、Powerpoint 等）。 R markdown 脚本通常用于创建动态和自动化报告。 本网站和指南也是用 R markdown 脚本制作的！

值得注意的是，初学者 R 用户也可以使用 R Markdown - 不要被吓倒！ 要了解更多信息，请参阅 [报告和 R Markdown] 页。

<!-- ======================================================= -->

### R notebooks {.unnumbered}

在 R Markdown 和 R notebook 中写作没有区别。 但是，文档的执行方式略有不同。 有关更多详细信息，请参阅此[站点](http://uc-r.github.io/r_notebook)。

<!-- ======================================================= -->

### Shiny {.unnumbered}

Shiny 的应用程序/网站包含在一个脚本中，该脚本必须命名为 `app.R`。 该文件包含三个组成部分：

1)  用户界面 (ui)\

2)  服务器函数\

3)  调用 `shinyApp` 函数

请参阅 [控制面板和 Shiny] 的指南页面，或此在线教程：[Shiny 教程](https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/)

在旧版本中，上述文件被拆分为两个文件（*`ui.R`* 和 *`server.R`*）

### 代码折叠 {.unnumbered}

您可以折叠部分代码以使脚本更易于阅读。

如果要折叠代码，请创建一个带有 \# 的文本标题，写下您的标题，并在其后至少使用 4 个短划线 (-)、散列 (\#) 或等号 (=)。 完成此操作后，左侧的"装订线"中会出现一个小箭头（按行号）。 您可以单击此箭头和下面的代码，直到下一个标题将折叠并且双箭头图标将出现在其位置。

要展开代码，请再次单击装订线中的箭头或双箭头图标。 有一些键盘快捷键也能实现此功能，如本页 [RStudio](#rstudio) 部分所述。

通过使用 \# 创建标题，您还将激活脚本底部的目录（见下文），您可以使用它来导航脚本。 您可以通过添加更多 \# 符号来创建子标题，例如，\# 表示一级标题，\#\# 表示二级标题，\#\#\# 表示三级标题。

下面是示例脚本的两个版本。 左边是带有注释标题的原件。 在右侧，每个标题后面都写了四个破折号，使它们可以折叠。 其中两个已折叠，您可以看到底部的目录现在显示了每个部分。

```{r, out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "code_folding1.png"))
knitr::include_graphics(here::here("images", "code_folding2.png"))
```

自动符合折叠条件的其他代码区域包括带括号`{ }`的区域，例如函数定义或条件块（if else 语句）。 您可以在 RStudio [站点](https://support.rstudio.com/hc/en-us/articles/200484568-Code-Folding-and-Sections)上阅读有关代码折叠的更多信息。

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## 工作目录

工作目录是在使用 R 时的根文件夹位置 - 默认情况下，R 会在其中查找和保存文件。 默认情况下，它会将新文件和输出保存到此位置，并将在此处查找要导入的文件（例如数据集）。

工作目录以灰色文本显示在 RStudio 控制台面板的顶部。 您还可以通过运行 `getwd()` （括号内为空）输出当前工作目录。

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "working_directory_1.png"))
```

### 管理方法推荐 {.unnumbered}

**有关我们推荐的用于管理工作目录的方法，请参阅 [R 项目] 页面。**

\
一种常见、高效且无故障的管理工作目录和文件路径的方法是之下3个步骤组成的工作流：

1)  R 项目用于存储所有文件（请参阅 [R 项目] 页面）\
2)  **here** package 用于定位文件（请参阅 [导入和导出] 页面）\
3)  **rio** package 用于导入/导出文件（请参阅 [导入和导出] 页面）

<!-- ======================================================= -->

### 通过命令设置工作目录 {.unnumbered}

迄今为止，许多学习 R 的人都被教导用 `setwd()` 命令开始他们的脚本。 请考虑使用面向 [R 项目] 的工作流程并阅读不建议使用 `setwd()` 的[原因](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/)。 简单来说，使用`setwd()`后，您的工作变得只适用于您的计算机。用于导入和导出文件的文件路径变得"脆弱"，这严重阻碍了您的代码在其他计算机上的协作和使用。 更何况有简单的替代方案！

虽然我们在大多数情况下不推荐这种方法，但您可以使用命令 `setwd()`并在引号中使用所需的文件路径，例如：

如果文件路径特定于一台计算机，则使用 setwd() 设置工作目录可能会"脆弱"

```{r, eval=F}
setwd("C:/Documents/R Files/My analysis")
```

[**警告:** 如果用 `setwd()`设置工作目录，会使得文件路径基于特定的电脑并且很"脆弱"。取而代之的是，用 **here** package 可以设置相对R项目根目录的文件路径。]{style="color: red;"}

<!-- ======================================================= -->

### 手动设置工作目录 {.unnumbered}

要手动设置工作目录（相当于 `setwd()` 的点击式设置），请单击会话 （session）下拉菜单并转到"设置工作目录"，然后转到"选择目录"。 这将为该 R 会话设置工作目录。 注意：如果使用这种方法，每次打开 RStudio 时都必须手动执行此操作。

<!-- ======================================================= -->

### R项目中的工作目录 {.unnumbered}

如果使用 R 项目，工作目录将默认为包含".rproj"文件的 R 项目根文件夹。 如果您通过单击R 项目文件（带有".rproj"扩展名的文件）来打开 RStudio，工作目录也将默认为 R 项目根文件夹。

<!-- ======================================================= -->

### R markdown 中的工作目录 {.unnumbered}

在 R markdown 脚本中，默认工作目录是保存 Rmarkdown 文件 (.Rmd) 的文件夹。 如果使用 R 项目和 **here** package，工作目录将是 `here()`，正如 [R 项目] 页面中所述。

如果您想更改为独立的 R markdown 的工作目录（不在 R 项目中），使用`setwd()`是不可行的，这将仅适用于该特定代码块。 要对 R markdown 中的所有代码块进行更改，请在设置块添加`root.dir =` 参数，如下所示：

```{r, eval=F}
knitr::opts_knit$set(root.dir = 'desired/directorypath')
```

在 R 项目中使用 R markdown 和 **here** package 要容易得多。

<!-- ======================================================= -->

### 提供文件路径 {.unnumbered}

对于 R 初学者（至少在 Windows 机器上）来说，最常见的失败可能来自于输入文件路径以导入或导出数据。 在[导入和导出]页面中有关于如何输入文件路径的详尽解释，但这里有几个关键点：

**不可用的路径**

以下是"绝对"或"完整"的文件路径的示例。 如果被另一台计算机使用，此路径可能不可用。 一个例外是使用的是共享/网络驱动器的时候。

    C:/Users/Name/Document/Analytic Software/R/Projects/Analysis2019/data/March2019.csv  

**斜线方向**

当手动输入文件路径时，请注意斜线的方向。 使用正斜杠 (`/`) 分隔组件 ("data/provincial.csv")。 对于 Windows 用户，文件路径的默认显示方式是使用反斜杠 (\\) - 因此您需要更改每个斜杠的方向。 如果您按照 [R 项目] 页面中的描述使用 **here** package ，则可忽略斜线方向问题。

**相对文件路径**

我们通常建议提供"相对的"文件路径，即相对于 R 项目根目录的路径。 您可以按照 [R 项目] 页面中的说明使用 **here** package 创建路径。 相对文件路径如下所示：

```{r, eval=F}
# 导入 csv linelist 来自于R项目的 data/linelist/clean/ sub-folders 文件
linelist <- import(here("data", "clean", "linelists", "marin_country.csv"))
```

即使在 R 项目中使用相对文件路径，您仍然可以使用绝对路径在 R 项目之外导入/导出数据。

<!-- ======================================================= -->

## 对象 {#objects}

R 中的一切都是对象，而 R 是一种"面向对象"语言。 本模块将解释：

-   如何创建对象 (`<-`)
-   对象的结构种类（例如数据框、向量...）
-   如何访问对象的子部分（例如数据集中的变量）
-   对象的类（例如数字、逻辑、整数、双精度、字符、因子）

<!-- ======================================================= -->

### 一切内容皆是对象 {.unnumbered}

本节改编自 [*R4Epis*](https://r4epis.netlify.app/training/r_basics/objects/) 项目。

您在 R 中存储的所有内容------数据集、变量、村庄名称列表、总人口数，甚至诸如图表之类的输出------都是被分配了名称的对象，可以在以后的命令中引用。

当你给它赋值时，一个对象就存在了（参见下面的赋值部分）。 当它被赋值时，对象出现在环境面板中（参见 RStudio 的右上面板）。 然后用户可以对其进行操作、更改和重新定义。.

<!-- ======================================================= -->

### 定义对象 (`<-`) {.unnumbered}

**通过使用 \<- 运算符为对象赋值来创建对象。**\
您可以将赋值运算符 `<-`视为词语"被定义为"。 赋值命令通常遵循标准顺序：

**对象名称** \<- **被赋予的值**（或产生值的过程与计算）

例如，您可能希望将当前的流行病学报告周作为对象，以便在以后的代码中进行引用。 在此示例中，对象 `current_week` 在被分配值`"2018-W10"`时创建（引号使其成为字符值）。 然后对象 `current_week` 将出现在 RStudio 环境面板（右上角）中，并且可以在以后的命令中引用。.

请参阅下面框中的 R 命令及其输出。

```{r basics_objects_assignment}
current_week <- "2018-W10"   # 此命令通过为其赋予一个值来创建对象 current_week
current_week                 # 此命令在控制台中打印 current_week 对象的当前值
```

[**注释:** R 控制台输出的`[1]`只是表明您正在查看的是输出的第一项]{style="color: black;"}

[**警示*:*** 通过运行复制命令重新对对象进行赋值，可以随时**覆盖对象的值。** 因此，**命令的顺序是极其重要的**。]{style="color: orange;"}

以下命令将重新定义 `current_week`的值：

```{r basics_objects_reassignment}
current_week <- "2018-W51"   # 为对象 current_week分配一个新值
current_week                 # 在控制台中打印 current_week 的当前值
```

**等号 `=`**

您在 R 代码中也会看到等号：

-   两个对象或值之间的双等号`==` 代表一个逻辑问题："这两个对象或值相等吗？"。.\
-   您还将在函数中指定函数参数值的时候看到等号（在下面的章节中会有相关内容），例如 `max(age, na.rm = TRUE)`。\
-   您可以使用单个等号 `=` 代替 `<-` 来创建和定义对象，但用户不被鼓励这样做。 您可以在[此处](https://renkun.me/2014/01/28/difference-between-assignment-operators-in-r/)阅读有关信息。

**数据集**

数据集也是对象（通常也被称作"数据框"），在导入时必须被指定名称。 在下面的代码中，创建了对象 `linelist` 并使用 **rio** package 及 `import()`函数为其分配了CSV 文件的值。

```{r basics_objects_dataframes, eval=FALSE}
# 已创建 linelist 并为其分配导入的 CSV 文件的值
linelist <- import("my_linelist.csv")
```

您可以在 [导入和导出] 部分阅读有关导入和导出数据集的更多信息。

[**警示:** 关于对象命名的快速说明:]{style="color: orange;"}

-   对象名称不得包含空格，您可以使用下划线 (\_) 或句点 (.)代替空格。
-   对象名称区分大小写（意味着 Dataset_A 与 dataset_A 是不同的对象）。
-   对象名称必须以字母开头（不能以 1、2 或 3 之类的数字开头）。

**输出**

表格和绘图等输出选项可以将输出另存为对象或仅打印而不保存。 使用 **base** R 的函数 `table()` 可以将性别和结果交叉表直接打印到 R 控制台（不会被保存）。

```{r}
# 仅打印到 R 控制台
table(linelist$gender, linelist$outcome)
```

但是同一个表可以被保存为命名对象。 然后它可以可选地被打印。

```{r}
# 保存
gen_out_table <- table(linelist$gender, linelist$outcome)

# 打印
gen_out_table
```

**列**

数据集内的列也是对象，可以按照下面关于列的部分中的描述进行定义、覆盖和创建。

您可以使用 **base** R 中的赋值运算符来创建新列。 以下示例创建了新列 `bmi`（身体质量指数），对于每一行，其值是对 `wt_kg` 和 `ht_cm` 列中的行值进行数学运算的结果。

```{r, eval=F}
# 使用base R 创建新的“bmi”列
linelist$bmi <- linelist$wt_kg / (linelist$ht_cm/100)^2
```

然而，在本手册中，我们倾向用另一种定义列，使用 **dplyr** package 中的函数 `mutate()` 和管道运算符 (%\>%)。 这样语法更易于阅读，并且在 [清理数据和核心功能] 页面中解释了其他优点。 您可以在下面的管道部分阅读有关管道运算的更多信息。

```{r, eval=F}
# 使用 dplyr 创建新的“bmi”列
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

<!-- ======================================================= -->

### 对象结构 {.unnumbered}

**对象可以是单条数据（例如 `my_number <- 24`），也可以由结构化数据组成。**

下图是来自一个在线 [R 教程](http://venus.ifca.unican.es/Rintro/dataStruct.html) 。 它显示了一些常见的数据结构及其名称。 此图像中未包含空间数据，其会在 [GIS 基础] 页面中进行讨论

```{r basics_objects_structures, echo=F, out.width = "75%", out.height="50%", fig.align = "center"}
knitr::include_graphics(here::here("images", "R_data_structures.png"))
```

在流行病学（尤其是现场流行病学）中，您最常会遇到数据框和向量：

+----------+------------------------------------------------------------------+------------------------------------------------------+
| 通用结构 | 解释                                                             | 例子                                                 |
+==========+==================================================================+======================================================+
| 向量     | 一个单一对象序列的容器，即所有对象都属于同一类（例如数字、字符） | 数据框中的"变量"（列）是向量（例如列 `age_years`）。 |
+----------+------------------------------------------------------------------+------------------------------------------------------+
| 数据框   | 绑定在一起的向量（例如列），且列都具有相同的行数。               | `linelist` 是一个数据框                              |
+----------+------------------------------------------------------------------+------------------------------------------------------+

请注意，要创建一个"独立"的向量（不是数据框的一部分），可以用函数 `c()`组合不同的元素。 例如，如果创建颜色图的色标向量：

`vector_of_colors <- c("blue", "red2", "orange", "grey")`

<!-- ======================================================= -->

### 对象的类 {.unnumbered}

R 中存储的所有对象都有一个类型，它能告诉 R 如何处理对象。 R 中有许多类，但常见的包括：

+----------------+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| 类             | 解释                                                                                                            | 例子                                                                                 |
+================+=================================================================================================================+======================================================================================+
| Character 字符 | 这些是"**引号内**"的文本/单词/句子。 无法对这些对象进行数学运算。                                               | "Character objects are in quotation marks"                                           |
+----------------+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Integer        | **只有整数**的数字（没有小数）                                                                                  | -5, 14, 或 2000                                                                      |
|                |                                                                                                                 |                                                                                      |
| 整数           |                                                                                                                 |                                                                                      |
+----------------+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Numeric        | 数字类型，**可以包括小数**。 如果在引号内，它们将被视为字符类。                                                 | 23.1 或 14                                                                           |
|                |                                                                                                                 |                                                                                      |
| 数值           |                                                                                                                 |                                                                                      |
+----------------+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Factor         | 这些是具有**指定顺序或值层次结构**的向量                                                                        | 具有有序值的经济状况变量                                                             |
|                |                                                                                                                 |                                                                                      |
| 因素           |                                                                                                                 |                                                                                      |
+----------------+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Date           | 一旦 R 被告知某些数据是日期，这些数据就可以以特殊的方式进行操作和显示。 有关详细信息，请参阅页面 [日期的使用]。 | 2018-04-12 或 15/3/1954 或 Wed 4 Jan 1980                                            |
|                |                                                                                                                 |                                                                                      |
| 日期           |                                                                                                                 |                                                                                      |
+----------------+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Logical        | 值必须是两个特殊值 TRUE 或 FALSE 之一（注意这些**不是**引号中的"TRUE"和"FALSE"）                                | TRUE 或 FALSE                                                                        |
|                |                                                                                                                 |                                                                                      |
| 逻辑           |                                                                                                                 |                                                                                      |
+----------------+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| data.frame     | 数据框是 R 典型的存储数据集的方式。 它由绑定在一起的数据向量（列）组成，它们都具有相同数量的观察（行）。        | 名为 `linelist_raw` 的示例 AJS 数据集包含 68 个变量，每个变量有 300 个观察值（行）。 |
|                |                                                                                                                 |                                                                                      |
| 数据框         |                                                                                                                 |                                                                                      |
+----------------+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| tibble         | tibbles 是数据框的一种变体，主要的操作区别在于它们可以更好地打印到控制台（显示前 10 行，仅显示适合屏幕的列）    | 任何数据框、列表或矩阵都可以使用 `as_tibble()` 转换为 tibble                         |
+----------------+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| list           | 列表类似于向量，但可以包含其他不同类的对象                                                                      | 一个列表可以包含一个数字、一个数据框、一个向量，甚至是另一个列表！                   |
|                |                                                                                                                 |                                                                                      |
| 列表           |                                                                                                                 |                                                                                      |
+----------------+-----------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+

您可以通过向函数**`class()`** 提供其名称来测试对象的类。 注意：您可以使用 \$ 符号来引用数据集中的特定列，以分隔数据集名称和列名称。

```{r, echo=TRUE,}
class(linelist)         # 类应该是数据框或 tibble

class(linelist$age)     # 类应该是数值

class(linelist$gender)  # 类应该是字符
```

有时，R 会自动将列转换为不同的类。请注意这一点！ 例如，如果您有一个向量或一列数字，但插入了一个字符值......整个列将更改为字符类。

```{r}
num_vector <- c(1,2,3,4,5) # 将向量定义为数字
class(num_vector)          # 向量是数值类
num_vector[3] <- "three"   # 将第三个元素转换为字符
class(num_vector)          # 向量现在是字符类
```

一个常见的例子是在操作数据框以打印表格时 - 如果您将所有行合并在一起并尝试将百分比与数字（例如 `23 (40%)`）粘贴/粘合在同一单元格中，则整个数字所在的列将转换为字符类，不能再用于数学计算。**有时，您需要将对象或列转换为另一个类。**

+------------------+-------------------------------------------------------------+
| 函数             | 作用                                                        |
+==================+=============================================================+
| `as.character()` | 转换为字符类                                                |
+------------------+-------------------------------------------------------------+
| `as.numeric()`   | 转换为数值类                                                |
+------------------+-------------------------------------------------------------+
| `as.integer()`   | 转换为整数类                                                |
+------------------+-------------------------------------------------------------+
| `as.Date()`      | 转换为日期类 - 注意：有关详细信息，请参阅[日期](#dates)部分 |
+------------------+-------------------------------------------------------------+
| `factor()`       | 转换为因素类 - 注意：重新定义值的顺序需要额外的参数         |
+------------------+-------------------------------------------------------------+

与此同时，有一些 **base** R 的函数来检查对象是否属于特定类，例如

[更多关于类和数据结构的在线资料。](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/)

<!-- ======================================================= -->

### 列/变量 (`$`) {.unnumbered}

**数据框中的一列在技术上是一个"向量"（见上表）**------一列必须包含属于同一类的值（字符、数字、逻辑等）。

向量可以独立于数据框而存在。例如，您希望得到在模型中作为解释的列名称向量。 要创建"独立"向量，请使用 `c()` 函数，如下所示：

```{r, warning=F, message=F}
# 定义独立的字符值向量
explanatory_vars <- c("gender", "fever", "chills", "cough", "aches", "vomit")

# 打印此向量中的值
explanatory_vars
```

**数据框中的列也是向量，可以使用 \$ 符号调用、引用、提取或创建。** \$ 符号将列的名称与其数据框的名称连接起来。 在本手册中，我们尝试使用"列"一词而不是"变量"。

```{r basics_objects_call, eval=F}
# 检索向量 age_years 的长度
length(linelist$age) # (age 是 linelist 数据框中的一列)

```

通过在数据框的名称后面写入 \$，您还将看到包含数据框中所有列的下拉菜单。 您可以使用箭头键滚动浏览它们，使用 Enter 键选择一个，这样避免拼写错误！

```{r echo=F, out.width = "100%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Calling_Names.gif"))
```

一些更复杂的对象（例如列表或epicontacts 对象）可能有多个级别，可以通过多个美元符号访问。 例如

[**高级提示:** 一些更复杂的对象（例如列表或者`epicontacts` 对象）可能存在多个级别，用户可以通过多个美元符号来访问。例如：]{style="color: darkgreen;"}

<!-- ======================================================= -->

### 使用方括号(`[ ]`)访问/索引 {.unnumbered}

您可能需要查看对象的一部分，也称为"索引"，这通常使用方括号 `[ ]`完成。 在数据帧上使用 `$` 来访问列也是一种索引。

```{r}
my_vector <- c("a", "b", "c", "d", "e", "f")  # 定义向量
my_vector[5]                                  # 打印第5个元素
```

方括号还可用于返回输出的特定部分，例如 `summary()` 函数的输出：

```{r}
# 所有的linelist$age的统计集合
summary(linelist$age)

# 只是统计集合的第二个元素，带有名称（仅使用单括号）
summary(linelist$age)[2]

# 只是统计集合的第二个元素，不带名称（使用双括号）
summary(linelist$age)[[2]]

# 按名称提取元素，不显示名称
summary(linelist$age)[["Median"]]

```

括号还可用于数据框以查看特定的行和列。 您可以使用语法`dataframe[rows, columns]`:

```{r basics_objects_access, eval=F}
# 查看数据集中的第2行，包含所有列（不要忘记逗号！）
linelist[2,]

# 查看所有行，但只看"date_onset"列
linelist[, "date_onset"]

# 查看第 2 行中第 5 到 10 列的值
linelist[2, 5:10] 

# 查看第 2 行中第 5 到 10 列再加上第18列的值
linelist[2, c(5:10, 18)] 

# 查看第 2 到 20 行中特定列的值
linelist[2:20, c("date_onset", "outcome", "age")]

# 根据条件查看行和列
# *** 请注意，数据框名字必须在条件中！
linelist[linelist$age > 25 , c("date_onset", "outcome", "age")]

# 使用 View() 在 RStudio Viewer 面板中查看输出（更易于阅读）
# *** 注意 View() 函数中的大写“V”
View(linelist[2:20, "date_onset"])

# 另存为新对象
new_table <- linelist[2:20, c("date_onset")] 
```

请注意，您还可以使用 **dplyr** 语法（针对行的函数 `filter()`和针对列的函数 `select()`）在数据框和tibbles 上实现上述行/列的索引。 在 [清理数据和核心功能] 页面中阅读有关这些功能的更多信息。

要根据"行号"进行过滤，您可以使用带有左括号的 **dplyr** 函数 `row_number()`作为逻辑过滤语句的一部分。 通常来说，您将使用 `%in%` 运算符和一系列数字作为该逻辑语句的一部分，如下所示。 要查看前 N 行，您还可以使用特殊的 **dplyr** 函数 `head()`。

```{r, eval=F}
# 查看前100行
linelist %>% head(100)

# 仅显示第 5 行
linelist %>% filter(row_number() == 5)

# 查看第 2 行到第 20 行其中三个特定的列（注意列名不需要引号）
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

当索引一个 **list** 列表的对象时，单括号总是与列表一起返回，即使只返回一个对象。 但是，双括号可用于访问单个元素并返回与列表不同的类。

括号也可以被顺序地书写，如下所示。

这个关于列表索引和胡椒瓶的[可视化示例](https://r4ds.had.co.nz/vectors.html#lists-of-condiments)非常幽默且有用。

```{r}
# 定义一个用于演示的列表
my_list <- list(
  # 列表中的第一个元素是一个字符向量
  hospitals = c("Central", "Empire", "Santa Anna"),
  
  # 列表中的第二个元素是地址的数据框
  addresses   = data.frame(
    street = c("145 Medical Way", "1048 Brown Ave", "999 El Camino"),
    city   = c("Andover", "Hamilton", "El Paso")
    )
  )
```

这是打印到控制台时列表的外观。 看看有两个被命名的元素

-   `hospitals`, 一个字符向量
-   `addresses`, 一个地址的数据框

```{r}
my_list
```

现在我们用不同方法提取对象：

```{r}
my_list[1] # 这将返回“list”类中的元素 - 元素名称仍然显示

my_list[[1]] # 这仅返回（未命名的）字符向量

my_list[["hospitals"]] # 您还可以按列表元素的名称索引

my_list[[1]][3] # 这将返回“医院”字符向量的第三个元素

my_list[[2]][1] # 这将返回地址数据框的第一列（“街道”）

```

<!-- ======================================================= -->

### 移除对象 {.unnumbered}

您可以通过将名称放在`rm()` 函数中（无引号）从 R 环境中删除单个对象：

```{r, eval=F}
rm(object_name)
```

您可以通过运行以下命令删除所有对象（清除工作区）：

```{r, eval=F}
rm(list = ls(all = TRUE))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## 管道 (`%>%`)

**一般用来处理对象的两种方法是：**

1)  **Pipes/tidyverse** - 管道从一个函数发送一个对象到另一个函数------重点是动作，而不是对象\
2)  **定义中间对象** - 一个对象一次又一次地被重新定义------重点是在这个对象上

<!-- ======================================================= -->

### 管道 {.unnumbered}

**简单解释一下，管道运算符 (`%>%`) 将中间输出从一个函数传递到下一个函数。**\
你可以把它想象成说"then"。 许多函数可以用 %\>% 链接在一起。

-   **管道强调一系列动作，而不是正在执行动作的对象**
-   当必须对一个对象执行一系列操作时，管道是最好用的
-   管道来自package **magrittr**，它自动包含在packages **dplyr** 和 **tidyverse** 中
-   管道可以使代码更干净、更易于阅读、更直观

在 tidyverse [指南](https://style.tidyverse.org/pipes.html)中阅读有关此方法的更多信息

这里有一个用于比较的假设示例，使用虚构的函数"bake a cake 烘培蛋糕"。首先是用管道的方法：

```{r piping_example_pipe, eval=F}
# 如何使用管道语法bake a cake烘培蛋糕的假示例

cake <- flour %>%       # 要定义蛋糕，先从面粉开始，然后…
  add(eggs) %>%   # 加鸡蛋
  add(oil) %>%    # 加黄油
  add(water) %>%  # 加水
  mix_together(         # 混合
    utensil = spoon,
    minutes = 2) %>%    
  bake(degrees = 350,   # 烘培
       system = "fahrenheit",
       minutes = 35) %>%  
  let_cool()            # 冷却
```

此[链接](https://cfss.uchicago.edu/notes/pipes/#:~:text=Pipes%20are%20an%20extremely%20useful,code%20and%20combine%20multiple%20operations)也描述管道的效用。

管道不是 **base** 的函数。 要使用管道，必须安装并加载 **magrittr** package（这通常通过加载包含它的 **tidyverse**或 **dplyr** package 来完成）。 您可以在[magrittr 文档](https://magrittr.tidyverse.org/)中阅读更多有关管道的信息。

请注意，就像其他 R 命令一样，管道可用于仅显示结果，或保存/重新保存对象，具体取决于是否涉及赋值运算符 `<-` 。 请比较以下两者：

```{r, eval=F}
# 创建或覆盖对象，定义为按年龄类别的聚合计数(不打印)
linelist_summary <- linelist %>% 
  count(age_cat)
```

```{r}
# 在控制台打印计数表，但不保存
linelist %>% 
  count(age_cat)
```

**`%<>%`**\
这是来自 magrittr package的"分配管道"，它通向前一个对象，并重新定义该对象。 它必须是链中的第一个管道操作符。 它是简写的。 以下两个命令是等效的：

```{r, eval=F}
linelist <- linelist %>%
  filter(age > 50)

linelist %<>% filter(age > 50)
```

<!-- ======================================================= -->

### 定义中间对象 {.unnumbered}

在以下情况下，这种更改对象/数据框的方法可能会更好：

-   您需要操作多个对象\
-   有一些有意义的中间步骤，需要单独的对象名称

**风险:**

-   为每一步创建新对象意味着要创建大量对象。 如果你用错了某个对象，你可能不会意识到！\
-   命名所有对象可能会令人困惑\
-   错误可能不容易检测到

要么命名每个中间对象，要么覆盖原始对象，或者将所有函数组合在一起。 每个方法都有自己的风险。

下面是与上面相同的假"蛋糕"示例，但使用现在的样式：

```{r piping_example_redefine, eval=F}
# 如何使用此方法烘焙蛋糕的虚拟示例（定义中间对象）
batter_1 <- left_join(flour, eggs)
batter_2 <- left_join(batter_1, oil)
batter_3 <- left_join(batter_2, water)

batter_4 <- mix_together(object = batter_3, utensil = spoon, minutes = 2)

cake <- bake(batter_4, degrees = 350, system = "fahrenheit", minutes = 35)

cake <- let_cool(cake)
```

将所有函数组合在一起 - 这很难阅读：

```{r eval=F}
# 将多个函数组合/嵌套在一起的示例 - 难以阅读
cake <- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = "fahrenheit", minutes = 35))
```

<!-- ======================================================= -->

## 关键运算符和函数 {#operators}

本节详细介绍 R 中的运算符，例如：

-   赋值运算符

-   关系运算符（小于，等于..）\

-   逻辑运算符（和，或...）

-   处理缺失值\

-   数学运算符和函数（+/-、\>、sum()、median()、...）\

-   %in% 运算符

<!-- ======================================================= -->

### 赋值运算符 {.unnumbered}

**`<-`**

R 中的基本赋值运算符是 `<-`，例如 `object_name <- value`。这个赋值运算符也可以写成`=`。 我们建议在R中一般使用 `<-` 。我们还建议将此类运算符周围增加空格，以提高可读性。

**`<<-`**

如果需要 [编写函数](#编写函数)，或以交互方式使用 R 与源脚本，那么您可能需要使用此赋值运算符 `<<-`（来自**base** R）。 此运算符用于在更高的"父级"R 环境中定义对象。 请参阅[在线参考资料](https://stat.ethz.ch/R-manual/R-devel/library/base/html/assignOps.html)。

**`%<>%`**

这是来自 magrittr package的"分配管道"，它通向前一个对象，并重新定义该对象。 它必须是链中的第一个管道操作符。 它是简写的。 以下两个命令是等效的：

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age_months = age_years * 12)
```

上面命令的等效于下面的：

```{r, eval=F}
linelist %<>% mutate(age_months = age_years * 12)
```

**`%<+%`**

这用于使用 **ggtree** package 将数据添加到系统发育树。 请参阅 [系统发育树] 上的页面或此[在线资源](https://yulab-smu.top/treedata-book/)。

<!-- ======================================================= -->

### 关系和逻辑运算符 {.unnumbered}

关系运算符比较数值，通常在定义新变量和数据集子集时使用。 以下是 R 中常见的关系运算符：

+--------------+------------+--------------+---------------------------------------------------------------------------------------------------+
| 含义         | 运算符     | 例子         | 例子结果                                                                                          |
+==============+============+==============+===================================================================================================+
| 等于？       | `==`       | `"A" == "a"` | `FALSE` 因为 R 区分大小写）请注意 ==（双等号）与 =（单等号）不同，后者的作用类似于赋值操作 *`<-`* |
+--------------+------------+--------------+---------------------------------------------------------------------------------------------------+
| 不等于？     | `!=`       | `2 != 0`     | `TRUE`                                                                                            |
+--------------+------------+--------------+---------------------------------------------------------------------------------------------------+
| 大于？       | `>`        | `4 > 2`      | `TRUE`                                                                                            |
+--------------+------------+--------------+---------------------------------------------------------------------------------------------------+
| 小于？       | `<`        | `4 < 2`      | `FALSE`                                                                                           |
+--------------+------------+--------------+---------------------------------------------------------------------------------------------------+
| 大于或等于？ | `>=`       | `6 >= 4`     | `TRUE`                                                                                            |
+--------------+------------+--------------+---------------------------------------------------------------------------------------------------+
| 小于或等于？ | `<=`       | `6 <= 4`     | `FALSE`                                                                                           |
+--------------+------------+--------------+---------------------------------------------------------------------------------------------------+
| 缺失值？     | `is.na()`  | `is.na(7)`   | `FALSE` (见[缺失数据]页面)                                                                        |
+--------------+------------+--------------+---------------------------------------------------------------------------------------------------+
| 不缺失值？   | `!is.na()` | `!is.na(7)`  | `TRUE`                                                                                            |
+--------------+------------+--------------+---------------------------------------------------------------------------------------------------+

逻辑运算符，例如 AND（和） 和 OR（或），通常用于连接关系运算符并创建更复杂的条件。 复杂的语句可能需要括号 ( ) 来进行分组和确定顺序。

+----------+-----------------------------------------------------------+
| 含义     | 运算符                                                    |
+==========+===========================================================+
| 和       | `&`                                                       |
+----------+-----------------------------------------------------------+
| 或       | `|` (垂直线条)                                            |
+----------+-----------------------------------------------------------+
| 括号包含 | `( )` 用于将标准组合在一起并阐明操作顺序                  |
+----------+-----------------------------------------------------------+

例如，在下面，我们有一个包含两个变量的行列表，我们想用它来创建我们的案例，`hep_e_rdt`，一个测试结果和 `other_cases_in_hh`，它将告诉我们家庭中是否还有其他案例。 下面的命令使用函数 `case_when()` 创建新变量 `case_def`：

```{r eval=FALSE}
linelist_cleaned <- linelist %>%
  mutate(case_def = case_when(
    is.na(rdt_result) & is.na(other_case_in_home)            ~ NA_character_,
    rdt_result == "Positive"                                 ~ "Confirmed",
    rdt_result != "Positive" & other_cases_in_home == "Yes"  ~ "Probable",
    TRUE                                                     ~ "Suspected"
  ))
```

+------------------------------------------------------------------------------+----------------------------+
| 以上例子中的条件                                                             | 新变量"case_def"中的结果值 |
+==============================================================================+============================+
| 如果变量 `rdt_result` 和 `other_cases_in_home` 的值丢失                      | `NA` (missing)             |
+------------------------------------------------------------------------------+----------------------------+
| 如果 `rdt_result` 中的值为"Positive"                                         | "Confirmed"                |
+------------------------------------------------------------------------------+----------------------------+
| 如果`rdt_result`中的值不是"Positive"并且 `other_cases_in_home` 中的值是"Yes" | "Probable"                 |
+------------------------------------------------------------------------------+----------------------------+
| 如果不满足上述条件之一                                                       | "Suspected"                |
+------------------------------------------------------------------------------+----------------------------+

请注意，R 区分大小写，因此"Positive"与"positive"不同......

<!-- ======================================================= -->

### 缺失值 {.unnumbered}

在 R 中，缺失值由特殊值 NA（"保留"值）（大写字母 N 和 A 且不在引号中）表示。 如果您以其他方式导入记录缺失值的数据（例如 99、"Missing"或 .），您可能需要将这些值重新编码为 NA。 [导入和导出]页面中介绍了如何执行此操作。

要测试值是否为 **`NA`**，请使用特殊函数**`is.na()`**，它返回 `TRUE` 或 `FALSE`。

```{r basics_operators_missing}
rdt_result <- c("Positive", "Suspected", "Positive", NA)   # 两例阳性，一例疑似，一例未知
is.na(rdt_result)  # 测试 rdt_result 的值是否为 NA
```

在 [缺失数据] 页面中有关于缺失值、无限值、`NULL` 和不可能值的更多信息。 在[导入导出]页面了解导入数据时如何转换缺失值。

<!-- ======================================================= -->

### 数学和统计运算符 {.unnumbered}

此页面中的所有运算符和函数均可基于**base** R使用。

#### 数学运算符 {.unnumbered}

这些运算符通常用于执行加法、除法、创建新列等。以下是 R 中常见的数学运算符。是否在运算符周围放置空格并不影响结果。

| 目的     | 例子   |
|----------|--------|
| 加法     | 2 + 3  |
| 减法     | 2 - 3  |
| 乘法     | 2 \* 3 |
| 除法     | 30 / 5 |
| 指数运算 | 2\^3   |
| 操作顺序 | ( )    |

#### 数学函数 {.unnumbered}

| 目的         | 函数                                  |
|--------------|---------------------------------------|
| 舍入         | round(x, digits = n)                  |
| 舍入         | janitor::round_half_up(x, digits = n) |
| 向上取舍     | ceiling(x)                            |
| 向下取舍     | floor(x)                              |
| 绝对值       | abs(x)                                |
| 开平方       | sqrt(x)                               |
| 幂           | exponent(x)                           |
| 自然对数     | log(x)                                |
| 10基底的对数 | log10(x)                              |
| 2基底的对数  | log2(x)                               |

注意：对于 `round()`，`digits =`指定小数位数。 使用 `signif()`舍入到多个有效数字。

#### 科学记数法 {.unnumbered}

使用科学记数法的可能性取决于 `scipen`选项的值。

来自 `?options`: scipen 的文档显示有一个因素"scipen"决定以固定还是以指数表示打印数值。 正值偏向固定数值，负值偏向科学记数法：固定记数法将是首选，除非它比"scipen"数字更宽（位数更大）。

如果它被设置为一个较低的数字（例如 0），它将始终"打开"。 要在 R 会话中"关闭"科学记数法，请将其设置为一个非常高的数字，例如：

```{r, eval=F}
#关闭科学记数法
options(scipen=999)
```

#### 取舍 {.unnumbered}

[**警告*:*** `round()` 使用 "银行家取舍" 即仅当上位数是偶数才从0.5向上取舍。 而来自**janitor** 的函数`round_half_up()` 始终四舍五入。 请参考此[解释](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records-with-duplicated-values-for-specific-combinations-of-variables-with-get_dupes)]{style="color: red;"}

```{r}
# 为您的工作选择合适的舍入函数
round(c(2.5, 3.5))

janitor::round_half_up(c(2.5, 3.5))
```

#### 统计函数 {.unnumbered}

[**警示:** 默认情况下，以下函数将在计算中包含缺失值。缺失值将会导致输出`NA` 除非指定 `na.rm = TRUE。`可以简写为`na.rm = T`. 。]{style="color: orange;"}

| 目的     | 函数               |
|----------|--------------------|
| 平均值   | mean(x, na.rm=T)   |
| 中位数   | median(x, na.rm=T) |
| 标准差   | sd(x, na.rm=T)     |
| 分位数\* | quantile(x, probs) |
| 总计     | sum(x, na.rm=T)    |
| 最小值   | min(x, na.rm=T)    |
| 最大值   | max(x, na.rm=T)    |
| 数值范围 | range(x, na.rm=T)  |
| 总结\*\* | summary(x)         |

注意:

-   `*quantile()`: `x` 是要检查的数值向量, 而 `probs =` 是概率在 0 和 1.0 之间的数值向量, e.g `c(0.5, 0.8, 0.85)`
-   `**summary()`: 给出数值向量的摘要，包括均值、中位数和常见百分位数

[**警告:** 如果为上述任何函数提供计算值，请确保数值被包在`c()` 中。]{style="color: red;"}

```{r}
# 如果向函数提供原始数值，请将它们包在 c() 中
mean(1, 6, 12, 10, 5, 0)    # !!! 不正确 !!!  

mean(c(1, 6, 12, 10, 5, 0)) # 正确
```

#### 其他有用的函数 {.unnumbered}

+---------------+-------------------+-------------------------------------------------+
| 目的          | 函数              | 例子                                            |
+===============+===================+=================================================+
| 创建一个序列  | seq(from, to, by) | `seq(1, 10, 2)`                                 |
+---------------+-------------------+-------------------------------------------------+
| 重复 x, n 次  | rep(x, ntimes)    | `rep(1:3, 2)` or `rep(c("a", "b", "c"), 3)`     |
+---------------+-------------------+-------------------------------------------------+
| 拆分数值向量  | cut(x, n)         | `cut(linelist$age, 5)`                          |
+---------------+-------------------+-------------------------------------------------+
| 生成随机样本  | sample(x, size)   | `sample(linelist$id, size = 5, replace = TRUE)` |
+---------------+-------------------+-------------------------------------------------+

<!-- ======================================================= -->

### `%in%` {.unnumbered}

一个非常有用的运算符，用于匹配值，以及快速评估该值是否在向量或数据框内。

```{r}
my_vector <- c("a", "b", "c", "d")
```

```{r}
"a" %in% my_vector
"h" %in% my_vector
```

要询问一个值是不是**不在**向量，请在逻辑语句**前**放置一个感叹号 (!)：

```{r}
# 要表示否定，在前面加上感叹号
!"a" %in% my_vector
!"h" %in% my_vector
```

`%in%` 在使用 dplyr 函数 `case_when()` 时非常有用。 您可以先定义一个向量，然后再引用它。 例如：

```{r eval=F}
affirmative <- c("1", "Yes", "YES", "yes", "y", "Y", "oui", "Oui", "Si")

linelist <- linelist %>% 
  mutate(child_hospitaled = case_when(
    hospitalized %in% affirmative & age < 18 ~ "Hospitalized Child",
    TRUE                                      ~ "Not"))
```

注意：如果您想检测部分字符串，可能使用 stringr 中的 `str_detect()`，它不会接受像 `c("1", "Yes", "yes", "y")`这样的字符向量。 相反，它必须被赋予一个正则表达式 - 一个带有 OR 的精简字符串像"1\|Yes\|yes\|y"。 例如，`str_detect(hospitalized, "1|Yes|yes|y")`。 有关更多信息，请参阅 [字符和字符串] 页面。

您可以使用以下命令将字符向量转换为命名的正则表达式：

```{r}
affirmative <- c("1", "Yes", "YES", "yes", "y", "Y", "oui", "Oui", "Si")
affirmative

# 精简
affirmative_str_search <- paste0(affirmative, collapse = "|")  # 基于 base R 
affirmative_str_search <- str_c(affirmative, collapse = "|")   # 基于 stringr package

affirmative_str_search
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## 错误（Error )和警告(Warning)

本节解释了：

-   错误和警告的区别\
-   编写 R 代码时的一般语法提示\
-   代码辅助

常见错误和警告以及故障排除方法可以在 [错误和帮助] 页面中找到。.

<!-- ======================================================= -->

### 错误（Error ) VS警告 (Warning) {.unnumbered}

运行命令时，R 控制台可能会以红色文本显示警告或错误消息。

-   警告意味着 R 已完成您的命令，但必须采取额外的步骤或产生了您应该注意的异常输出。

-   错误意味着 R 无法完成您的命令。

寻找错误和警告的线索:

-   错误/警告消息通常会包含出现问题的行号。

-   如果某个对象"未知 unknown"或"未找到 not found"，则可能是您拼写错误，忘记使用 library() 调用package ，或者在进行更改后忘记重新运行脚本。

如果所有方法都不管用，请将错误消息以及一些关键术语复制到 Google 或百度中 - 很可能其他人已经解决了这个问题！

<!-- ======================================================= -->

### 一般语法技巧 {.unnumbered}

在 R 中编写命令时要记住的一些技巧，以避免错误和警告：

-   始终闭合括号 - 提示：计算每个代码块的左括号"("和右括号")"的数量
-   避免在列名和对象名中使用空格。 改用下划线 ( \_ ) 或句点 ( . )
-   跟踪并记住用逗号分隔函数的参数
-   R 区分大小写，这意味着 `Variable_A` 与 `variable_A` 不同

<!-- ======================================================= -->

### 代码辅助 {.unnumbered}

任何脚本（RMarkdown 或其他脚本）都会在您犯错时提供线索。 例如，如果您忘记在需要的地方写逗号，或者忘记关闭括号，RStudio 将在脚本右侧的该行上引发一个标志，以警告您。


# Grouping data { }  
# 分组数据 { }  


```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Grouping_1500x500.png"))
```


This page covers how to group and aggregate data for descriptive analysis. It makes use of the **tidyverse** family of packages for common and easy-to-use functions. 


Grouping data is a core component of data management and analysis. Grouped data statistically summarised by group, and can be plotted by group. Functions from the **dplyr** package (part of the **tidyverse**) make grouping and subsequent operations quite easy.  

本章介绍如何应用**tidyverse**包的常用和易用的系列函数来进行数据分组和汇总等描述性分析。

数据分组是数据管理和分析的核心组成部分。分组数据按组统计汇总，并可按组作图。**dplyr**包（**tidyverse**族包之一）的函数使分组和后续操作很容易。

This page will address the following topics:  

* Group data with the `group_by()` function  
* Un-group data  
* `summarise()` grouped data with statistics  
* The difference between `count()` and `tally()`  
* `arrange()` applied to grouped data  
* `filter()` applied to grouped data  
* `mutate()` applied to grouped data  
* `select()` applied to grouped data  
* The **base** R `aggregate()` command as an alternative  

本章主要解决如下问题：
* 用`group_by()`函数分组数据
* 取消分组
* `summarise()`统计分析分组数据
* `count()`与`tally()`的区别
* `arrange()` 用于分组数据  
* `filter()` 用于分组数据 
* `mutate()` 用于分组数据  
* `select()` 用于分组数据  
* **base** R `aggregate()` 命令替代  


<!-- ======================================================= -->
## Preparation {  }
## 准备工作 {  }
     
### Load packages {.unnumbered}  
### 加载包 {.unnumbered}  
     
This code chunk shows the loading of packages required for the analyses. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load installed packages with  `library()` from **base** R. See the page on [R basics] for more information on R packages.  

此代码块显示了分析所需包的加载。在本手册中，我们推荐用**pacman**包的`p_load()`函数，其在必要时安装*并*加载相应的包以供使用。还可用**base** R的`library()`加载已安装的包。有关R语言包的更多信息，请参阅[R基础知识]章节。

```{r}
pacman::p_load(
  rio,       # to import data
  here,      # to locate files
  tidyverse, # to clean, handle, and plot the data (includes dplyr)
  janitor)   # adding total rows and columns
```

```{r}
pacman::p_load(
  rio,       # 导入数据
  here,      # 定位文件
  tidyverse, # 清洗、处理数据并绘图 (含dplyr包)
  janitor)   # 添加汇总行列
```




### Import data {.unnumbered}
### 导入数据 {.unnumbered}

We import the dataset of cases from a simulated Ebola epidemic. If you want to follow along, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the "clean" linelist</a> (as .rds file). The dataset is imported using the `import()` function from the **rio** package. See the page on [Import and export] for various ways to import data.

导入一个模拟埃博拉疫情病例数据集。要继续的话，<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>请点击下载“整洁”的病例一览表数据集</a> (.rds格式文件)。此数据集用**rio**包的`import()`函数导入。导入数据的更多方法请参阅[导入和导出]章节。

```{r, echo=F}
linelist <- rio::import(here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
linelist <- import("linelist_cleaned.rds")
```


The first 50 rows of `linelist`:  
`linelist`的前50行：

```{r message=FALSE, echo=F}
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



<!-- ======================================================= -->
## Grouping {  }
## 分组 {  }
     
The function `group_by()` from **dplyr** groups the rows by the unique values in the column specified to it. If multiple columns are specified, rows are grouped by the unique combinations of values across the columns. Each unique value (or combination of values) constitutes a group. Subsequent changes to the dataset or calculations can then be performed within the context of each group.  



For example, the command below takes the `linelist` and groups the rows by unique values in the column `outcome`, saving the output as a new data frame `ll_by_outcome`. The grouping column(s) are placed inside the parentheses of the function `group_by()`.  

**dplyr**包的`group_by()`函数可按指定列的唯一值来对行进行分组。如果指定多个列，则行按这些列中唯一值的组合进行分组。每个唯一值（或值的组合）构成一个组。后续对数据集的操作和计算将在每个组范围内执行。

例如，下面的命令将`linelist`根据`outcome`列中的唯一值对行进行分组，将输出保存为新的数据框`ll_by_outcome`。分组列名置于`group_by()`函数的括号内。
```{r}
ll_by_outcome <- linelist %>% 
  group_by(outcome)
```

**Note that there is no perceptible change to the dataset** after running `group_by()`, *until* another **dplyr** verb such as `mutate()`, `summarise()`, or `arrange()` is applied on the "grouped" data frame.  

You can however "see" the groupings by printing the data frame. When you print a grouped data frame, you will see it has been transformed into a [`tibble` class object](https://tibble.tidyverse.org/) which, when printed, displays which groupings have been applied and how many groups there are - written just above the header row.  

**请注意，`group_by()`运行后数据集并没有明显变化**，其他`dplyr`动词（例如`mutate()`、`summarise()`或`arrange()`）应用于“分组”数据框后会有明显不同。

但是，可以通过打印数据框来“查看”分组。当打印分组数据框时，会看到它已被转换为一个[`tibble`类对象](https://tibble.tidyverse.org/) ，该对象在打印时会显示已应用的分组以及有多少组 - 一般输出在列名行上方。

```{r}
# print to see which groups are active
ll_by_outcome
```

```{r}
# 打印查看有效分组情况
ll_by_outcome
```


### Unique groups {.unnumbered}  
### 独特组 {.unnumbered}  

**The groups created reflect each unique combination of values across the grouping columns.** 

To see the groups *and the number of rows in each group*, pass the grouped data to `tally()`. To see just the unique groups without counts you can pass to `group_keys()`.  

See below that there are **three** unique values in the grouping column `outcome`: "Death", "Recover", and `NA`. See that there were `r nrow(linelist %>% filter(outcome == "Death"))` deaths, `r nrow(linelist %>% filter(outcome == "Recover"))` recoveries, and `r nrow(linelist %>% filter(is.na(outcome)))` with no outcome recorded.

**创建的组反映了分组列中值的每个唯一组合。**

要查看组*和每个组中的行数*，请将分组数据传递给`tally()`。要仅查看没有计数的独特组，可以传递给`group_keys()`.

下面的分组列`outcome`中有三个唯一值：“死亡”、“恢复”和`NA`。数据集中有`r nrow(linelist %>% filter(outcome == "Death"))`行死亡记录、`r nrow(linelist %>% filter(outcome == "Recover"))`康复记录和`r nrow(linelist %>% filter(is.na(outcome)))`无结局记录。

```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally()
```


You can group by more than one column. Below, the data frame is grouped by `outcome` and `gender`, and then tallied. Note how each unique combination of `outcome` and `gender` is registered as its own group - including missing values for either column.   

可以按多个列进行分组。下面，数据框按`outcome`和`gender`分组，然后进行计数。请注意`outcome`和`gender`的每个唯一值组合是如何登录为分组的 - 包括任一列的缺省值。

```{r}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally()
```

### New columns {.unnumbered} 
### 新列 {.unnumbered} 

You can also create a new grouping column *within* the `group_by()` statement. This is equivalent to calling `mutate()` before the `group_by()`. For a quick tabulation this style can be handy, but for more clarity in your code consider creating this column in its own `mutate()` step and then piping to `group_by()`.
还可在group_by()语句*内部*创建一个新的分组列。这相当于在运行`group_by()`前调用了`mutate()`。对于快速制表来说，这种方式可能很方便，但为了使代码更加清晰，还是建议在单独的`mutate()`步骤中创建此列，然后通过管道传递给`group_by()`为宜。

```{r}
# group dat based on a binary column created *within* the group_by() command
linelist %>% 
  group_by(
    age_class = ifelse(age >= 18, "adult", "child")) %>% 
  tally(sort = T)
```
```{r}
# 在group_by()语句*内部*创建了一个二分类变量来分组数据
linelist %>% 
  group_by(
    age_class = ifelse(age >= 18, "adult", "child")) %>% 
  tally(sort = T)
```

### Add/drop grouping columns {.unnumbered}  
### 添加/删除分组列 {.unnumbered}  

By default, if you run `group_by()` on data that are already grouped, the old groups will be removed and the new one(s) will apply. If you want to add new groups to the existing ones, include the argument `.add = TRUE`.  

默认情况下，在已分组的数据上运行`group_by()`，则旧组将被删除并应用新组。如果要向现有组添加新组，请添加参数`.add = TRUE`。

````{r, eval=F}
# Grouped by outcome
by_outcome <- linelist %>% 
  group_by(outcome)

# Add grouping by gender in addition
by_outcome_gender <- by_outcome %>% 
  group_by(gender, .add = TRUE)
```
````{r, eval=F}
# 用outcome分组
by_outcome <- linelist %>% 
  group_by(outcome)

# 另外添加gender列分组
by_outcome_gender <- by_outcome %>% 
  group_by(gender, .add = TRUE)
```


** Keep all groups**  
** 保留所有组**  

If you group on a column of class factor there may be levels of the factor that are not currently present in the data. If you group on this column, by default those non-present levels are dropped and not included as groups. To change this so that all levels appear as groups (even if not present in the data), set `.drop = FALSE` in your `group_by()` command.  

在对因子类的列进行分组时，可能出现数据中有的因子水平不存的情况。这时，如果在此列上分组，默认情况下这些不存在的因子水平将被删除且不纳入分组。要更改此设置以使所有水平都显示为组别（即使数据中不存在），请在`group_by()`命令中设置`.drop = FALSE`参数。

## Un-group  
## 取消分组  

Data that have been grouped will remain grouped until specifically ungrouped via `ungroup()`. If you forget to ungroup, it can lead to incorrect calculations! Below is an example of removing all groupings:  

已分组的数据将保持分组状态，直到用`ungroup()`专门取消分组。如果忘记取消分组，可能会导致计算错误！以下是删除所有分组的示例：

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup()
```

You can also remove grouping for only specific columns, by placing the column name inside `ungroup()`.  
也可以为特定列取消分组，方法是将该列名置于`ungroup()`函数内。

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup(gender) # remove the grouping by gender, leave grouping by outcome
```

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup(gender) # 取消gender分组，保留outcome分组
```


<span style="color: black;">**_NOTE:_** The verb `count()` automatically ungroups the data after counting.</span>

<span style="color: black;">**_注意：_** `count()`在完成计算后会自动取消分组。</span>



## Summarise {#group_summarise} 
## 汇总 {#group_summarise} 

See the **dplyr** section of the [Descriptive tables] page for a detailed description of how to produce summary tables with `summarise()`. Here we briefly address how its behavior changes when applied to grouped data.  

关于如何用`summarise()`制作汇总表的详细描述请参阅**dplyr**部分的[描述性表格]章节。本节简要介绍一下其应用于分组数据时的运行情况。


The **dplyr** function `summarise()` (or `summarize()`) takes a data frame and converts it into a *new* summary data frame, with columns containing summary statistics that you define. On an ungrouped data frame, the summary statistics will be calculated from all rows. Applying `summarise()` to grouped data produces those summary statistics *for each group*.  

**dplyr**包的`summarise()`（或`summarize()`）函数将把一个数据框转换成一个含 有指定汇总统计信息的*新*摘要数据框。在未分组的数据框中，`summarise()`将对所有行进行统计汇总计算，而对于分组数据，则会对*每一组*进行组内所有行的统计汇总计算。

The syntax of `summarise()` is such that you provide the name(s) of the **new** summary column(s), an equals sign, and then a statistical function to apply to the data, as shown below. For example, `min()`, `max()`, `median()`, or `sd()`. Within the statistical function, list the column to be operated on and any relevant argument (e.g. `na.rm = TRUE`). You can use `sum()` to count the number of rows that meet a logical criteria (with double equals `==`).  

`summarise()`的语法是这样的：提供汇总生成**新**列的名称、等号，然后是一个拟采用的统计函数，如下所示的如，`min()`，`max()`，`median()`或`sd()`等。在统计函数中，列出要操作的列和任何相关参数（例如 `na.rm = TRUE`）。可以使用`sum()`来计算满足逻辑条件的行数（使用双等号`==`）。

Below is an example of `summarise()` applied *without grouped data*. The statistics returned are produced from the entire dataset.    
下面是一个没有分组数据的`summarise()`应用示例。返回的统计数据是从整个数据集生成的。

```{r}
# summary statistics on ungrouped linelist
linelist %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males  = sum(gender == "m", na.rm=T))
```

In contrast, below is the same `summarise()` statement applied to grouped data. The statistics are calculated for each `outcome` group. Note how grouping columns will carry over into the new data frame.    
相比之下，下面是`summarise()`应用于分组数据的相同语句，为每个`outcome`组计算统计数据。请注意分组列将如何延续到新数据框中。

```{r}
# 分组linelist数据集的统计汇总
linelist %>% 
  group_by(outcome) %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males    = sum(gender == "m", na.rm=T))
```

<span style="color: darkgreen;">**_TIP:_** The summarise function works with both UK and US spelling - `summarise()` and `summarize()` call the same function.</span>

<span style="color: darkgreen;">**_技巧：_** summarise函数可以在英式和美式拼写都有效- `summarise()` 和 `summarize()` 将调用同一个函数。</span>




## Counts and tallies  
## 计数与小计  

`count()` and `tally()` provide similar functionality but are different. Read more about the distinction between `tally()` and `count()` [here](https://dplyr.tidyverse.org/reference/tally.html)  

`count()` 和 `tally()`提供了类似的功能但有区别。有关两者间的区别的更多信息，请参阅[这里](https://dplyr.tidyverse.org/reference/tally.html)。

### `tally()` {.unnumbered}  
### `tally()` {.unnumbered}  

`tally()` is shorthand for `summarise(n = n())`, and *does not* group data. Thus, to achieve grouped tallys it must follow a `group_by()` command. You can add `sort = TRUE` to see the largest groups first.    
`tally()`是`summarise(n = n())`的缩写形式，但其*不*分组数据。因此，要计算分组合计就必须使用`group_by()`命令，然后可以再添加`sort = TRUE`参数可以对结果降序排列把最大值组排在前面方便查看。

```{r}
linelist %>% 
  tally()
```


```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally(sort = TRUE)
```


### `count()`  {.unnumbered}  

In contrast, `count()` does the following:  

1) applies `group_by()` on the specified column(s)  
2) applies `summarise()` and returns column `n` with the number of rows per group  
3) applies `ungroup()`  

相比之下，`count()`执行如下操作：
1）调用`group_by()`指定分组列
2）调用`summarise()`返回包含每组的行数的新列`n`
3）调用`ungroup()`取消分组

```{r}
linelist %>% 
  count(outcome)
```

Just like with `group_by()` you can create a new column within the `count()` command:  

就像`group_by()`一样，可以在`count()`命令中创建一个新列：

```{r}
linelist %>% 
  count(age_class = ifelse(age >= 18, "adult", "child"), sort = T)
```


`count()` can be called multiple times, with the functionality "rolling up". For example, to summarise the number of hospitals present for each gender, run the following. Note, the name of the final column is changed from default "n" for clarity (with `name  = `).  

count()可以多次调用，具有“上卷”功能。例如，要汇总每个性别的医院数量，运行以下命令。请注意，为了清晰起见，最后一列的名称（用`name =`）可更改默认的列名“n”。

```{r}
linelist %>% 
  # produce counts by unique outcome-gender groups
  count(gender, hospital) %>% 
  # gather rows by gender (3) and count number of hospitals per gender (6)
  count(gender, name = "hospitals per gender" ) 
```


```{r}
linelist %>% 
     # 产生性别-医院独特值组计数
     count(gender, hospital) %>% 
     # 按性别汇总行(3)且计算每个性别的医院数量(6)
     count(gender, name = "hospitals per gender" ) 
```


### Add counts {.unnumbered}  
### 添加计数 {.unnumbered}  

In contrast to `count()` and `summarise()`, you can use `add_count()` to *add* a new column `n` with the counts of rows per group *while retaining all the other data frame columns*.   
相比于`count()`和`summarise()`，可用`add_count()`计算每组行数*添加*生成一个新列`n`，同时*保留了数据框所其他所有列*。

This means that a group's count number, in the new column `n`, will be printed in each row of the group. For demonstration purposes, we add this column and then re-arrange the columns for easier viewing. See the section below on [filter on group size](#group_filter_grp_size) for another example.  

这意味着在新列`n`中的每组计数会打印在该组的每行中。为了演示方便，我们添加这一列并对各列进行重新排序便于查看。另一个相关示例请参阅[按组大小筛选](#group_filter_grp_size)。


```{r}
linelist %>% 
  as_tibble() %>%                   # convert to tibble for nicer printing 
  add_count(hospital) %>%           # add column n with counts by hospital
  select(hospital, n, everything()) # re-arrange for demo purposes
```
```{r}
linelist %>% 
  as_tibble() %>%                   # 转成美观打印的数据框 
  add_count(hospital) %>%           # 按医院添加计数列n
  select(hospital, n, everything()) # 为演示重新排序
```



### Add totals {.unnumbered} 
### 添加合计 {.unnumbered} 

To easily add total *sum* rows or columns after using `tally()` or `count()`, see the **janitor** section of the [Descriptive tables](#tbl_janitor) page. This package offers functions like `adorn_totals()` and `adorn_percentages()` to add totals and convert to show percentages. Below is a brief example:

要在使用`tally()`或`count()`后轻松地添加总的*sum*行或列，请参阅[描述性表格](#tbl_janitor)章节的**janitor**部分。该包提供了`adorn_totals()`和`adorn_percentages()`等函数，用于添加总数和转换显示百分比。下面是一个简单的示例。

```{r}
linelist %>%                                  # case linelist
  tabyl(age_cat, gender) %>%                  # cross-tabulate counts of two columns
  adorn_totals(where = "row") %>%             # add a total row
  adorn_percentages(denominator = "col") %>%  # convert to proportions with column denominator
  adorn_pct_formatting() %>%                  # convert proportions to percents
  adorn_ns(position = "front") %>%            # display as: "count (percent)"
  adorn_title(                                # adjust titles
    row_name = "Age Category",
    col_name = "Gender")
```
```{r}
linelist %>%                                  # 病例一览表
  tabyl(age_cat, gender) %>%                  # 两列的计数交叉表
  adorn_totals(where = "row") %>%             # 添加一个合计行
  adorn_percentages(denominator = "col") %>%  # 换算列构成比
  adorn_pct_formatting() %>%                  # 将构成比换算成百分数格式
  adorn_ns(position = "front") %>%            # 显示为：“计数（百分比）”
  adorn_title(                                # 调整标题
    row_name = "Age Category",
    col_name = "Gender")
```
```


To add more complex totals rows that involve summary statistics other than *sums*, see [this section of the Descriptive Tables page](#tbl_dplyr_totals). 

要添加含除*sums之外的汇总统计 更复杂的合计行，请参见[描述性表格](#tbl_dplyr_totals)章节部分。

## Grouping by date  
## 按日期分组  

When grouping data by date, you must have (or create) a column for the date unit of interest - for example "day", "epiweek", "month", etc. You can make this column using `floor_date()` from **lubridate**, as explained in the [Epidemiological weeks section](#dates_epi_wks) of the [Working with dates] page. Once you have this column, you can use `count()` from **dplyr** to group the rows by those unique date values and achieve aggregate counts. 
当按日期分组时，必须有（或创建）一个拟研究的日期单位的列--例如 “日”、“流行病学周”、“月 ”等。可使用**lubridate**包的`floor_date()`函数来创建这样的列，详见在[处理日期]章节的[流行病学周](#dates_epi_wks)部分中的介绍。一旦有了这一列，就可以使用**dplyr**包的`count()`函数，通过这些唯一的日期值对行进行分组，实现汇总计数。


One additional step common for date situations, is to "fill-in" any dates in the sequence that are not present in the data. Use `complete()` from **tidyr** so that the aggregated date series is *complete* including *all possible date units* within the range. Without this step, a week with no cases reported might not appear in your data!  

处理日期时，一个常见的额外步骤是使用**tidyr**包的`complete()`函数"来填补 "数据的日期序列中不存在的任何日期。这样汇总的日期序列是*完整的*，包括该日期范围内*所有可能的日期单位*。如果没有这个步骤，一个没有病例报告的星期单位可能不会出现在数据中!  

Within `complete()` you *re-define* your date column as a *sequence* of dates `seq.Date()` from the minimum to the maximum  - thus the dates are expanded. By default, the case count values in any new "expanded" rows will be `NA`. You can set them to 0 using the `fill = ` argument of `complete()`, which expects a named list (if your counts column is named `n`, provide `fill = list(n = 0)`). See `?complete` for details and the [Working with dates](#dates_epi_wks) page for an example.  

在`complete()`中，*重新定义*数据的日期列作为一个从最小到最大的日期*序列*`seq.Date()` - 因此日期被扩展。默认情况下，任何新的“扩展”出来的行中的病例计数值将是`NA`。可以使用`complete()`的`fill = `参数将其设置为0，该参数可接受一个命名的列表（如果计数列被命名为`n`，需提供`fill = list(n = 0)`）。可在R控制台输入并运行`?complete`查看帮助页和参阅在[处理日期](#dates_epi_wks)章节中的示例。 


### Linelist cases into days  {.unnumbered}  
### 以天为单位的病例数  {.unnumbered}  

Here is an example of grouping cases into days *without* using `complete()`. Note the first rows skip over dates with no cases.  
下面是一个在没有使用“complete()”的情况下将病例分组到天的例子。注意前几行命令将没有病例的日期忽略掉了。 


```{r}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%        # remove that were missing date_onset
  count(date_onset)              # count number of rows per unique date
```

```{r}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%        # 删除发病日期缺省的病例
  count(date_onset)              # 计算每个独特日期的行数
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Below we add the `complete()` command to ensure every day in the range is represented.

下面添加`complete()`命令以确保指定日期范围内的每一天都出现。

```{r, eval=F}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # remove case missing date_onset
  count(date_onset) %>%                   # count number of rows per unique date
  complete(                               # ensure all days appear even if no cases
    date_onset = seq.Date(                # re-define date colume as daily sequence of dates
      from = min(date_onset, na.rm=T), 
      to = max(date_onset, na.rm=T),
      by = "day"),
    fill = list(n = 0))                   # set new filled-in rows to display 0 in column n (not NA as default) 
```
```{r, eval=F}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # 删除发病日期缺省的病例
  count(date_onset) %>%                   # 计算每个独特日期的行数
  complete(                               # 确保没有病例的日期也出现
    date_onset = seq.Date(                # 重新定义日期列为以天为单位的日期序列
      from = min(date_onset, na.rm=T), 
      to = max(date_onset, na.rm=T),
      by = "day"),
    fill = list(n = 0))                   # 设置n列中新填充值为0（非默认的NA） 
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Linelist cases into weeks {.unnumbered}  
### 以周为单位的病例数 {.unnumbered}  


The same principle can be applied for weeks. First create a new column that is the week of the case using `floor_date()` with `unit = "week"`. Then, use `count()` as above to achieve weekly case counts. Finish with `complete()` to ensure that all weeks are represented, even if they contain no cases.

同样的原则也可以适用于周数。首先使用`floor_date()`函数和`unit = "week"`参数可以创建一个新的列作为病例的报告星期。然后，像上面一样使用`count()`来计数每周的病例数。最后用`complete()`来确保所有的星期都出现在数据集里，包括那些没有病 例报告的星期。

```{r}
# Make dataset of weekly case counts
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # remove cases missing date_onset
  mutate(week = lubridate::floor_date(date_onset, unit = "week")) %>%  # new column of week of onset
  count(week) %>%                         # group data by week and count rows per group
  complete(                               # ensure all days appear even if no cases
    week = seq.Date(                      # re-define date colume as daily sequence of dates
      from = min(week, na.rm=T), 
      to = max(week, na.rm=T),
      by = "week"),
    fill = list(n = 0))                   # set new filled-in rows to display 0 in column n (not NA as default) 
```

```{r}
# 生成周发病数据集
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # 删除发病日期缺省的病例
  mutate(week = lubridate::floor_date(date_onset, unit = "week")) %>%  # 新的发病星期列
  count(week) %>%                         # 数据按星期分组并计算每组的行数
  complete(                               # 确保无病例报告的星期也出现
    week = seq.Date(                      # 重新定义日期列为以周为单位的日期序列
      from = min(week, na.rm=T), 
      to = max(week, na.rm=T),
      by = "week"),
    fill = list(n = 0))                   # 设置n列中新填充值为0（非默认的NA）
```

Here are the first 50 rows of the resulting data frame:  
下面是新生成数据框的前50行：

```{r message=FALSE, echo=F}
DT::datatable(weekly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Linelist cases into months {.unnumbered}
### 以月为单位的病例数 {.unnumbered}

To aggregate cases into months, again use `floor_date()` from the **lubridate** package, but with the argument `unit = "months"`. This rounds each date down to the 1st of its month. The output will be class Date. Note that in the `complete()` step we also use `by = "months"`.  

要将病例汇总到月，再次使用**lubridate**包中的`floor_date()`函数，但参数为`unit = "month"`。这将使每个日期向下四舍五入到其月份第1天。输出结果将是日期类。注意在`complete()`步骤中也要使用`by = "month"`。 


```{r}
# 生成月发病数据集
monthly_counts <- linelist %>% 
  drop_na(date_onset) %>% 
  mutate(month = lubridate::floor_date(date_onset, unit = "months")) %>%  # 新列，发病日期月份的第1天
  count(month) %>%                          # 按月计数病例
  complete(
    month = seq.Date(
      min(month, na.rm=T),                  # 包含无病例报告的所有月份
      max(month, na.rm=T),
      by="month"),
    fill = list(n = 0))
```

```{r message=FALSE, echo=F}
DT::datatable(monthly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Daily counts into weeks {.unnumbered}
### 每日发病数汇总到周 {.unnumbered}

To aggregate daily counts into weekly counts, use `floor_date()` as above. However, use `group_by()` and `summarize()` instead of `count()` because you need to `sum()` daily case counts instead of just counting the number of rows per week.

要把每天计数汇总成每周计数，请上述方法使用`floor_date()`。但是这里得使用`group_by()`和`summarize()`，而不是`count()`，因为现在需要`sum()`每日病例计数，而不是仅仅计算每周的行数。


#### Daily counts into months {.unnumbered}
#### 每日发病计数汇总到月 {.unnumbered}

To aggregate daily counts into months counts, use `floor_date()` with `unit = "month"` as above. However, use `group_by()` and `summarize()` instead of `count()` because you need to `sum()` daily case counts instead of just counting the number of rows per month.  

要把每天计数汇总成每月计数，请使用带`unit = "month"`参数的`floor_date()`函数。但是这里得使用`group_by()`和`summarize()`，而不是`count()`，因为现在需要`sum()`每日病例计数，而不是仅仅计算每月的行数。




## Arranging grouped data
## 排序分组数据

Using the **dplyr** verb `arrange()` to order the rows in a data frame behaves the same when the data are grouped, *unless* you set the argument `.by_group =TRUE`. In this case the rows are ordered first by the grouping columns and then by any other columns you specify to `arrange()`.

数据分组后，使用**dplyr**动词`arrange()`来对数据框中的行进行排序与未分组时无异，**除非**设置参数`.by_group =TRUE`。在这种情况下，行会先按分组列排序，然后再按指定给`arrange()`的任何其他列排序。



## Filter on grouped data
## 分组数据筛选

### `filter()` {.unnumbered}
### `filter()` {.unnumbered}

When applied in conjunction with functions that evaluate the data frame (like `max()`, `min()`, `mean()`), these functions will now be applied to the groups. For example, if you want to filter and keep rows where patients are above the median age, this will now apply per group - filtering to keep rows above the *group's* median age. 

当与统计数据框的函数（如`max()`, `min()`, `mean()`）一起应用时，这些函数将被应用到各组中。例如，如果要筛选并保留患者年龄在中位数以上的行，这将适用于每个组--筛选以保留高于*各组*的中位数的行。



### Slice rows per group {.unnumbered} 
### 分组切片行 {.unnumbered} 

The **dplyr** function `slice()`, which [filters rows based on their position](https://dplyr.tidyverse.org/reference/slice.html) in the data, can also be applied per group. Remember to account for sorting the data within each group to get the desired "slice".  

**dplyr**包的`slice()`函数，可[根据位置筛选行](https://dplyr.tidyverse.org/reference/slice.html)，也可应用于每个组。记住要考虑到在每个组内对数据进行排序，以获得所需的 "切片"。 

For example, to retrieve only the latest 5 admissions from each hospital:  

1) Group the linelist by column `hospital`  
2) Arrange the records from latest to earliest `date_hospitalisation` *within each hospital group*  
3) Slice to retrieve the first 5 rows from each hospital  

例如，只检索每个医院最近的5个入院病例：

1) 按`hospital`列对病例一览表进行分组  
2) *在每个医院组内*，将记录按`date_hospitalisation`从最晚到最早排列 
3) 从每家医院中切片获取前5条记录 

```{r,}
linelist %>%
  group_by(hospital) %>%
  arrange(hospital, date_hospitalisation) %>%
  slice_head(n = 5) %>% 
  arrange(hospital) %>%                            # for display
  select(case_id, hospital, date_hospitalisation)  # for display
```

```{r,}
linelist %>%
  group_by(hospital) %>%
  arrange(hospital, date_hospitalisation) %>%
  slice_head(n = 5) %>% 
  arrange(hospital) %>%                            # 便于显示
  select(case_id, hospital, date_hospitalisation)  # 便于显示
```

`slice_head()` - selects n rows from the top  
`slice_tail()` - selects n rows from the end  
`slice_sample()` - randomly selects n rows  
`slice_min()` - selects n rows with highest values in `order_by = ` column, use `with_ties = TRUE` to keep ties  
`slice_max()` - selects n rows with lowest values in `order_by = ` column, use `with_ties = TRUE` to keep ties  

See the [De-duplication] page for more examples and detail on `slice()`.  

`slice_head()` - 从顶部选择n条记录  
`slice_tail()` - 从尾部选择n条记录  
`slice_sample()` - 随机选择n条记录  
`slice_min()` - 选择在`order_by = `列中数值最低的n条记录，使用`with_ties = TRUE`来保留并列值。 
`slice_max()` - 选择`order_by = `列中数值最高的n条记录，使用`with_ties = TRUE`来保持并列值。 

关于`slice()`的更多例子和细节，请参阅[数据去重]章节。 



### Filter on group size {#group_filter_grp_size .unnumbered} 
### 按组大小筛选 {#group_filter_grp_size .unnumbered} 

The function `add_count()` adds a column `n` to the original data giving the number of rows in that row's group. 

Shown below, `add_count()` is applied to the column `hospital`, so the values in the new column `n` reflect the number of rows in that row's hospital group. Note how values in column `n` are repeated. In the example below, the column name `n` could be changed using `name = ` within `add_count()`. For demonstration purposes we re-arrange the columns with `select()`.  

函数`add_count()`在原始数据中增加一列`n`，并给出各行分组的行数。

如下所示，`add_count()`应用于`hospital`列，所以新列`n`中的值代表该行医院分组的行数。注意`n`列中的数值是如何重复的。在下面的例子中，可以在`add_count()'中使用`name = `参数改变列名`n`。为了演示方便，用`select()`重新对各列排序。 

```{r}
linelist %>% 
  as_tibble() %>% 
  add_count(hospital) %>%          # add "number of rows admitted to same hospital as this row" 
  select(hospital, n, everything())
```

```{r}
linelist %>% 
  as_tibble() %>% 
  add_count(hospital) %>%          # 添加“与该行医院为同一医院的行数” 
  select(hospital, n, everything())
```

It then becomes easy to filter for case rows who were hospitalized at a "small" hospital, say, a hospital that admitted fewer than 500 patients: 

这样就很容易筛选出那些在“小”医院住院的病例行，比如说，收治病人少于500人的医院。 


```{r, eval=F}
linelist %>% 
  add_count(hospital) %>% 
  filter(n < 500)
```





## Mutate on grouped data  
## 分组数据计算  

To retain all columns and rows (not summarise) and *add a new column containing group statistics*, use `mutate()` after `group_by()` instead of `summarise()`. 

This is useful if you want group statistics in the original dataset *with all other columns present* - e.g. for calculations that compare one row to its group.  

For example, this code below calculates the difference between a row's delay-to-admission and the median delay for their hospital. The steps are:  

要保留所有的列和行（不是汇总），*添加一个包含组统计的新列*，请在`group_by()`之后使用`mutate()`而不是`summarise()`。

如果要在原始数据集中获得组的统计信息，又同时确保*其他列都存在*的情况下，这是非常有用的--例如，用于将某一行与它所在组进行比较的计算。 

例如，下面这段代码计算了某一行的入院延迟时间与该医院的延迟时间中位数之间的差异。其步骤是：  

1) Group the data by hospital  
2) Use the column `days_onset_hosp` (delay to hospitalisation) to create a new column containing the mean delay at the hospital of *that row*  
3) Calculate the difference between the two columns  

1）以hospital分组数据
2）用`days_onset_hosp`列（入院延迟时间）来创建一个包含*那行*医院延迟均数的新列
3）计算两列间的差值

We `select()` only certain columns to display, for demonstration purposes.  
为便于演示，仅`selection()`显示某些列

```{r}
linelist %>% 
  # group data by hospital (no change to linelist yet)
  group_by(hospital) %>% 
  
  # new columns
  mutate(
    # mean days to admission per hospital (rounded to 1 decimal)
    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),
    
    # difference between row's delay and mean delay at their hospital (rounded to 1 decimal)
    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %>%
  
  # select certain rows only - for demonstration/viewing purposes
  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)
```
```{r}
linelist %>% 
  # 按hospital分组数据（未改变一览表数据）
  group_by(hospital) %>% 
  
  # 新列
  mutate(
    # 每个医院延迟入院均数（精确至1位小数）
  group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),
    # 行延迟和所在医院延迟均数间差值（精确到1位小数）
  diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %>%
  
  # 为便于演示/查看，仅选择某些列 
  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)
```



## Select on grouped data  
## 分组数据选择  

The verb `select()` works on grouped data, but the grouping columns are always included (even if not mentioned in `select()`). If you do not want these grouping columns, use `ungroup()` first.  

动词`select()`对分组数据起作用，但分组列总是被包括在内（即使在`select()`中没有提到）。如果不想要这些分组列，请先使用`ungroup()`。 









<!-- ======================================================= -->
## Resources {  }

Here are some useful resources for more information:  
下面是有关信息的一些有用资源：
You can perform any summary function on grouped data; see the [RStudio data transformation cheat sheet](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf)  
可在分组数据是运行任何汇总函数；请参阅[Rstudio数据转换速查表](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf)  

The Data Carpentry page on [**dplyr**](https://datacarpentry.org/R-genomics/04-dplyr.html) 

数据工匠网站在线资源[**dplyr**](https://datacarpentry.org/R-genomics/04-dplyr.html) 

The **tidyverse** reference pages on [group_by()](https://dplyr.tidyverse.org/reference/group_by.html) and [grouping](https://dplyr.tidyverse.org/articles/grouping.html)  

**tidyverse** 在线参考资料[group_by()](https://dplyr.tidyverse.org/reference/group_by.html) 和 [grouping](https://dplyr.tidyverse.org/articles/grouping.html)  

本网页关于[数据操作](https://itsalocke.com/files/DataManipulationinR.pdf)  

[Summarize with conditions in dplyr](https://stackoverflow.com/questions/23528862/summarize-with-conditions-in-dplyr)

[用dplyr按条件汇总](https://stackoverflow.com/questions/23528862/summarize-with-conditions-in-dplyr)  






